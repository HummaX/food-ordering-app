{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst fs = require('fs');\nconst {\n  constants\n} = fs;\nconst {\n  Readable: ReadableStream,\n  Writable: WritableStream\n} = require('stream');\nconst {\n  inherits,\n  isDate\n} = require('util');\nconst FastBuffer = Buffer[Symbol.species];\nconst {\n  bufferCopy,\n  bufferSlice,\n  makeBufferParser,\n  writeUInt32BE\n} = require('./utils.js');\nconst ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n};\n\n// Large enough to store all possible attributes\nconst ATTRS_BUF = Buffer.alloc(28);\nconst STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nconst VALID_STATUS_CODES = new Map(Object.values(STATUS_CODE).map(n => [n, 1]));\nconst STATUS_CODE_STR = {\n  [STATUS_CODE.OK]: 'No error',\n  [STATUS_CODE.EOF]: 'End of file',\n  [STATUS_CODE.NO_SUCH_FILE]: 'No such file or directory',\n  [STATUS_CODE.PERMISSION_DENIED]: 'Permission denied',\n  [STATUS_CODE.FAILURE]: 'Failure',\n  [STATUS_CODE.BAD_MESSAGE]: 'Bad message',\n  [STATUS_CODE.NO_CONNECTION]: 'No connection',\n  [STATUS_CODE.CONNECTION_LOST]: 'Connection lost',\n  [STATUS_CODE.OP_UNSUPPORTED]: 'Operation unsupported'\n};\nconst REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nconst RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nconst OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nconst PKT_RW_OVERHEAD = 2 * 1024;\nconst MAX_REQID = 2 ** 32 - 1;\nconst CLIENT_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */, REQUEST.INIT, 0, 0, 0, 3 /* version */]);\n\nconst SERVER_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */, RESPONSE.VERSION, 0, 0, 0, 3 /* version */]);\n\nconst RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nconst OPENSSH_MAX_PKT_LEN = 256 * 1024;\nconst bufferParser = makeBufferParser();\nconst fakeStderr = {\n  readable: false,\n  writable: false,\n  push: data => {},\n  once: () => {},\n  on: () => {},\n  emit: () => {},\n  end: () => {}\n};\nfunction noop() {}\n\n// Emulates enough of `Channel` to be able to be used as a drop-in replacement\n// in order to process incoming data with as little overhead as possible\nclass SFTP extends EventEmitter {\n  constructor(client, chanInfo, cfg) {\n    super();\n    if (typeof cfg !== 'object' || !cfg) cfg = {};\n    const remoteIdentRaw = client._protocol._remoteIdentRaw;\n    this.server = !!cfg.server;\n    this._debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);\n    this._version = -1;\n    this._extensions = {};\n    this._biOpt = cfg.biOpt;\n    this._pktLenBytes = 0;\n    this._pktLen = 0;\n    this._pktPos = 0;\n    this._pktType = 0;\n    this._pktData = undefined;\n    this._writeReqid = -1;\n    this._requests = {};\n    this._maxInPktLen = OPENSSH_MAX_PKT_LEN;\n    this._maxOutPktLen = 34000;\n    this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this.maxOpenHandles = undefined;\n\n    // Channel compatibility\n    this._client = client;\n    this._protocol = client._protocol;\n    this._callbacks = [];\n    this._hasX11 = false;\n    this._exit = {\n      code: undefined,\n      signal: undefined,\n      dump: undefined,\n      desc: undefined\n    };\n    this._waitWindow = false; // SSH-level backpressure\n    this._chunkcb = undefined;\n    this._buffer = [];\n    this.type = chanInfo.type;\n    this.subtype = undefined;\n    this.incoming = chanInfo.incoming;\n    this.outgoing = chanInfo.outgoing;\n    this.stderr = fakeStderr;\n    this.readable = true;\n  }\n\n  // This handles incoming data to parse\n  push(data) {\n    if (data === null) {\n      cleanupRequests(this);\n      if (!this.readable) return;\n      // No more incoming data from the remote side\n      this.readable = false;\n      this.emit('end');\n      return;\n    }\n    /*\n        uint32             length\n        byte               type\n        byte[length - 1]   data payload\n    */\n    let p = 0;\n    while (p < data.length) {\n      if (this._pktLenBytes < 4) {\n        let nb = Math.min(4 - this._pktLenBytes, data.length - p);\n        this._pktLenBytes += nb;\n        while (nb--) this._pktLen = (this._pktLen << 8) + data[p++];\n        if (this._pktLenBytes < 4) return;\n        if (this._pktLen === 0) return doFatalSFTPError(this, 'Invalid packet length');\n        if (this._pktLen > this._maxInPktLen) {\n          const max = this._maxInPktLen;\n          return doFatalSFTPError(this, `Packet length ${this._pktLen} exceeds max length of ${max}`);\n        }\n        if (p >= data.length) return;\n      }\n      if (this._pktPos < this._pktLen) {\n        const nb = Math.min(this._pktLen - this._pktPos, data.length - p);\n        if (p !== 0 || nb !== data.length) {\n          if (nb === this._pktLen) {\n            this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);\n          } else {\n            if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);\n            this._pkt.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._pktPos);\n          }\n        } else if (nb === this._pktLen) {\n          this._pkt = data;\n        } else {\n          if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);\n          this._pkt.set(data, this._pktPos);\n        }\n        p += nb;\n        this._pktPos += nb;\n        if (this._pktPos < this._pktLen) return;\n      }\n      const type = this._pkt[0];\n      const payload = this._pkt;\n\n      // Prepare for next packet\n      this._pktLen = 0;\n      this._pktLenBytes = 0;\n      this._pkt = undefined;\n      this._pktPos = 0;\n      const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];\n      if (!handler) return doFatalSFTPError(this, `Unknown packet type ${type}`);\n      if (this._version === -1) {\n        if (this.server) {\n          if (type !== REQUEST.INIT) return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);\n        } else if (type !== RESPONSE.VERSION) {\n          return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);\n        }\n      }\n      if (handler(this, payload) === false) return;\n    }\n  }\n  end() {\n    this.destroy();\n  }\n  destroy() {\n    if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {\n      this.outgoing.state = 'closing';\n      this._protocol.channelClose(this.outgoing.id);\n    }\n  }\n  _init() {\n    this._init = noop;\n    if (!this.server) sendOrBuffer(this, CLIENT_VERSION_BUFFER);\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n  createReadStream(path, options) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    return new ReadStream(this, path, options);\n  }\n  createWriteStream(path, options) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    return new WriteStream(this, path, options);\n  }\n  open(path, flags_, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n    const flags = typeof flags_ === 'number' ? flags_ : stringToFlags(flags_);\n    if (flags === null) throw new Error(`Unknown flags string: ${flags_}`);\n    let attrsFlags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'string' || typeof attrs === 'number') attrs = {\n      mode: attrs\n    };\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      attrsFlags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32        id\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPEN;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    writeUInt32BE(buf, attrsFlags, p += 4);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPEN`);\n  }\n  close(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.CLOSE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} CLOSE`);\n  }\n  read(handle, buf, off, len, position, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf)) throw new Error('buffer is not a Buffer');\n    if (off >= buf.length) throw new Error('offset is out of bounds');\n    if (off + len > buf.length) throw new Error('length extends beyond buffer');\n    if (position === null) throw new Error('null position currently unsupported');\n    read_(this, handle, buf, off, len, position, cb);\n  }\n  readData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.read(handle, buf, off, len, position, cb);\n  }\n  write(handle, buf, off, len, position, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf)) throw new Error('buffer is not a Buffer');\n    if (off > buf.length) throw new Error('offset is out of bounds');\n    if (off + len > buf.length) throw new Error('length extends beyond buffer');\n    if (position === null) throw new Error('null position currently unsupported');\n    if (!len) {\n      cb && process.nextTick(cb, undefined, 0);\n      return;\n    }\n    const maxDataLen = this._maxWriteLen;\n    const overflow = Math.max(len - maxDataLen, 0);\n    const origPosition = position;\n    if (overflow) len = maxDataLen;\n\n    /*\n      uint32     id\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);\n    writeUInt32BE(out, out.length - 4, 0);\n    out[4] = REQUEST.WRITE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(out, reqid, 5);\n    writeUInt32BE(out, handleLen, p);\n    out.set(handle, p += 4);\n    p += handleLen;\n    for (let i = 7; i >= 0; --i) {\n      out[p + i] = position & 0xFF;\n      position /= 256;\n    }\n    writeUInt32BE(out, len, p += 8);\n    bufferCopy(buf, out, off, off + len, p += 4);\n    this._requests[reqid] = {\n      cb: err => {\n        if (err) {\n          if (typeof cb === 'function') cb(err);\n        } else if (overflow) {\n          this.write(handle, buf, off + len, overflow, origPosition + len, cb);\n        } else if (typeof cb === 'function') {\n          cb(undefined, off + len);\n        }\n      }\n    };\n    const isSent = sendOrBuffer(this, out);\n    if (this._debug) {\n      const how = isSent ? 'Sent' : 'Buffered';\n      this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);\n    }\n  }\n  writeData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.write(handle, buf, off, len, position, cb);\n  }\n  fastGet(remotePath, localPath, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    fastXfer(this, fs, remotePath, localPath, opts, cb);\n  }\n  fastPut(localPath, remotePath, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    fastXfer(fs, this, localPath, remotePath, opts, cb);\n  }\n  readFile(path, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof options === 'string') options = {\n      encoding: options,\n      flag: 'r'\n    };else if (!options) options = {\n      encoding: null,\n      flag: 'r'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    const encoding = options.encoding;\n    if (encoding && !Buffer.isEncoding(encoding)) throw new Error(`Unknown encoding: ${encoding}`);\n\n    // First stat the file, so we know the size.\n    let size;\n    let buffer; // Single buffer with file data\n    let buffers; // List for when size is unknown\n    let pos = 0;\n    let handle;\n\n    // SFTPv3 does not support using -1 for read position, so we have to track\n    // read position manually\n    let bytesRead = 0;\n    const flag = options.flag || 'r';\n    const read = () => {\n      if (size === 0) {\n        buffer = Buffer.allocUnsafe(8192);\n        this.read(handle, buffer, 0, 8192, bytesRead, afterRead);\n      } else {\n        this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);\n      }\n    };\n    const afterRead = (er, nbytes) => {\n      let eof;\n      if (er) {\n        eof = er.code === STATUS_CODE.EOF;\n        if (!eof) {\n          return this.close(handle, () => {\n            return callback && callback(er);\n          });\n        }\n      } else {\n        eof = false;\n      }\n      if (eof || size === 0 && nbytes === 0) return close();\n      bytesRead += nbytes;\n      pos += nbytes;\n      if (size !== 0) {\n        if (pos === size) close();else read();\n      } else {\n        // Unknown size, just read until we don't get bytes.\n        buffers.push(bufferSlice(buffer, 0, nbytes));\n        read();\n      }\n    };\n    afterRead._wantEOFError = true;\n    const close = () => {\n      this.close(handle, er => {\n        if (size === 0) {\n          // Collect the data into the buffers list.\n          buffer = Buffer.concat(buffers, pos);\n        } else if (pos < size) {\n          buffer = bufferSlice(buffer, 0, pos);\n        }\n        if (encoding) buffer = buffer.toString(encoding);\n        return callback && callback(er, buffer);\n      });\n    };\n    this.open(path, flag, 0o666, (er, handle_) => {\n      if (er) return callback && callback(er);\n      handle = handle_;\n      const tryStat = (er, st) => {\n        if (er) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          this.stat(path, (er_, st_) => {\n            if (er_) {\n              return this.close(handle, () => {\n                callback && callback(er);\n              });\n            }\n            tryStat(null, st_);\n          });\n          return;\n        }\n        size = st.size || 0;\n        if (size === 0) {\n          // The kernel lies about many files.\n          // Go ahead and try to read some bytes.\n          buffers = [];\n          return read();\n        }\n        buffer = Buffer.allocUnsafe(size);\n        read();\n      };\n      this.fstat(handle, tryStat);\n    });\n  }\n  writeFile(path, data, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof options === 'string') options = {\n      encoding: options,\n      mode: 0o666,\n      flag: 'w'\n    };else if (!options) options = {\n      encoding: 'utf8',\n      mode: 0o666,\n      flag: 'w'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    if (options.encoding && !Buffer.isEncoding(options.encoding)) throw new Error(`Unknown encoding: ${options.encoding}`);\n    const flag = options.flag || 'w';\n    this.open(path, flag, options.mode, (openErr, handle) => {\n      if (openErr) {\n        callback && callback(openErr);\n      } else {\n        const buffer = Buffer.isBuffer(data) ? data : Buffer.from('' + data, options.encoding || 'utf8');\n        const position = /a/.test(flag) ? null : 0;\n\n        // SFTPv3 does not support the notion of 'current position'\n        // (null position), so we just attempt to append to the end of the file\n        // instead\n        if (position === null) {\n          const tryStat = (er, st) => {\n            if (er) {\n              // Try stat() for sftp servers that may not support fstat() for\n              // whatever reason\n              this.stat(path, (er_, st_) => {\n                if (er_) {\n                  return this.close(handle, () => {\n                    callback && callback(er);\n                  });\n                }\n                tryStat(null, st_);\n              });\n              return;\n            }\n            writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);\n          };\n          this.fstat(handle, tryStat);\n          return;\n        }\n        writeAll(this, handle, buffer, 0, buffer.length, position, callback);\n      }\n    });\n  }\n  appendFile(path, data, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof options === 'string') options = {\n      encoding: options,\n      mode: 0o666,\n      flag: 'a'\n    };else if (!options) options = {\n      encoding: 'utf8',\n      mode: 0o666,\n      flag: 'a'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    if (!options.flag) options = Object.assign({\n      flag: 'a'\n    }, options);\n    this.writeFile(path, data, options, callback);\n  }\n  exists(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    this.stat(path, err => {\n      cb && cb(err ? false : true);\n    });\n  }\n  unlink(filename, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     filename\n    */\n    const fnameLen = Buffer.byteLength(filename);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REMOVE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, fnameLen, p);\n    buf.utf8Write(filename, p += 4, fnameLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REMOVE`);\n  }\n  rename(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     oldpath\n      string     newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RENAME;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, oldLen, p);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RENAME`);\n  }\n  mkdir(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.MKDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} MKDIR`);\n  }\n  rmdir(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RMDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RMDIR`);\n  }\n  readdir(where, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    if (typeof opts !== 'object' || opts === null) opts = {};\n    const doFilter = opts && opts.full ? false : true;\n    if (!Buffer.isBuffer(where) && typeof where !== 'string') throw new Error('missing directory handle or path');\n    if (typeof where === 'string') {\n      const entries = [];\n      let e = 0;\n      const reread = (err, handle) => {\n        if (err) return cb(err);\n        this.readdir(handle, opts, (err, list) => {\n          const eof = err && err.code === STATUS_CODE.EOF;\n          if (err && !eof) return this.close(handle, () => cb(err));\n          if (eof) {\n            return this.close(handle, err => {\n              if (err) return cb(err);\n              cb(undefined, entries);\n            });\n          }\n          for (let i = 0; i < list.length; ++i, ++e) entries[e] = list[i];\n          reread(undefined, handle);\n        });\n      };\n      return this.opendir(where, reread);\n    }\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = where.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(where, p += 4);\n    this._requests[reqid] = {\n      cb: doFilter ? (err, list) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        for (let i = list.length - 1; i >= 0; --i) {\n          if (list[i].filename === '.' || list[i].filename === '..') list.splice(i, 1);\n        }\n        cb(undefined, list);\n      } : cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READDIR`);\n  }\n  fstat(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSTAT`);\n  }\n  stat(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.STAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STAT`);\n  }\n  lstat(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.LSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} LSTAT`);\n  }\n  opendir(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPENDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPENDIR`);\n  }\n  setstat(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SETSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SETSTAT`);\n  }\n  fsetstat(handle, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     handle\n      ATTRS      attrs\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSETSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    writeUInt32BE(buf, flags, p += handleLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSETSTAT`);\n  }\n  futimes(handle, atime, mtime, cb) {\n    return this.fsetstat(handle, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  utimes(path, atime, mtime, cb) {\n    return this.setstat(path, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  fchown(handle, uid, gid, cb) {\n    return this.fsetstat(handle, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  chown(path, uid, gid, cb) {\n    return this.setstat(path, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  fchmod(handle, mode, cb) {\n    return this.fsetstat(handle, {\n      mode: mode\n    }, cb);\n  }\n  chmod(path, mode, cb) {\n    return this.setstat(path, {\n      mode: mode\n    }, cb);\n  }\n  readlink(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READLINK;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing link info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READLINK`);\n  }\n  symlink(targetPath, linkPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     linkpath\n      string     targetpath\n    */\n    const linkLen = Buffer.byteLength(linkPath);\n    const targetLen = Buffer.byteLength(targetPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SYMLINK;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    if (this._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      writeUInt32BE(buf, targetLen, p);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n      writeUInt32BE(buf, linkLen, p += targetLen);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n    } else {\n      writeUInt32BE(buf, linkLen, p);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n      writeUInt32BE(buf, targetLen, p += linkLen);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SYMLINK`);\n  }\n  realpath(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REALPATH;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing path info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REALPATH`);\n  }\n  // extended requests\n  ext_openssh_rename(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['posix-rename@openssh.com'];\n    if (!ext || ext !== '1') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"posix-rename@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 24, p);\n    buf.utf8Write('posix-rename@openssh.com', p += 4, 24);\n    writeUInt32BE(buf, oldLen, p += 24);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);\n    }\n  }\n  ext_openssh_statvfs(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['statvfs@openssh.com'];\n    if (!ext || ext !== '2') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"statvfs@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 19, p);\n    buf.utf8Write('statvfs@openssh.com', p += 4, 19);\n    writeUInt32BE(buf, pathLen, p += 19);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      extended: 'statvfs@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);\n    }\n  }\n  ext_openssh_fstatvfs(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['fstatvfs@openssh.com'];\n    if (!ext || ext !== '2') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fstatvfs@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('fstatvfs@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, handleLen, p += 20);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      extended: 'fstatvfs@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);\n    }\n  }\n  ext_openssh_hardlink(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['hardlink@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"hardlink@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('hardlink@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, oldLen, p += 20);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);\n    }\n  }\n  ext_openssh_fsync(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['fsync@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fsync@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 17, p);\n    buf.utf8Write('fsync@openssh.com', p += 4, 17);\n    writeUInt32BE(buf, handleLen, p += 17);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} fsync@openssh.com`);\n  }\n  ext_openssh_lsetstat(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['lsetstat@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32    id\n      string    \"lsetstat@openssh.com\"\n      string    path\n      ATTRS     attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('lsetstat@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);\n    }\n  }\n  ext_openssh_expandPath(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['expand-path@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"expand-path@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 23, p);\n    buf.utf8Write('expand-path@openssh.com', p += 4, 23);\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);\n    }\n  }\n  ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['copy-data'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(srcHandle)) throw new Error('Source handle is not a Buffer');\n    if (!Buffer.isBuffer(dstHandle)) throw new Error('Destination handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"copy-data\"\n      string    read-from-handle\n      uint64    read-from-offset\n      uint64    read-data-length\n      string    write-to-handle\n      uint64    write-to-offset\n    */\n    let p = 0;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8);\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n    writeUInt32BE(buf, 9, p);\n    p += 4;\n    buf.utf8Write('copy-data', p, 9);\n    p += 9;\n    writeUInt32BE(buf, srcHandle.length, p);\n    p += 4;\n    buf.set(srcHandle, p);\n    p += srcHandle.length;\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = srcOffset & 0xFF;\n      srcOffset /= 256;\n    }\n    p += 8;\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = len & 0xFF;\n      len /= 256;\n    }\n    p += 8;\n    writeUInt32BE(buf, dstHandle.length, p);\n    p += 4;\n    buf.set(dstHandle, p);\n    p += dstHandle.length;\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = dstOffset & 0xFF;\n      dstOffset /= 256;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} copy-data`);\n    }\n  }\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n  handle(reqid, handle) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    const handleLen = handle.length;\n    if (handleLen > 256) throw new Error('handle too large (> 256 bytes)');\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.HANDLE;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    if (handleLen) buf.set(handle, p += 4);\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} HANDLE`);\n  }\n  status(reqid, code, message) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!VALID_STATUS_CODES.has(code)) throw new Error(`Bad status code: ${code}`);\n    message || (message = '');\n    const msgLen = Buffer.byteLength(message);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.STATUS;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, code, p);\n    writeUInt32BE(buf, msgLen, p += 4);\n    p += 4;\n    if (msgLen) {\n      buf.utf8Write(message, p, msgLen);\n      p += msgLen;\n    }\n    writeUInt32BE(buf, 0, p); // Empty language tag\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STATUS`);\n  }\n  data(reqid, data, encoding) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    const isBuffer = Buffer.isBuffer(data);\n    if (!isBuffer && typeof data !== 'string') throw new Error('data is not a Buffer or string');\n    let isUTF8;\n    if (!isBuffer && !encoding) {\n      encoding = undefined;\n      isUTF8 = true;\n    }\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.DATA;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, dataLen, p);\n    if (dataLen) {\n      if (isBuffer) buf.set(data, p += 4);else if (isUTF8) buf.utf8Write(data, p += 4, dataLen);else buf.write(data, p += 4, dataLen, encoding);\n    }\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} DATA`);\n  }\n  name(reqid, names) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!Array.isArray(names)) {\n      if (typeof names !== 'object' || names === null) throw new Error('names is not an object or array');\n      names = [names];\n    }\n    const count = names.length;\n    let namesLen = 0;\n    let nameAttrs;\n    const attrs = [];\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      const filename = !name || !name.filename || typeof name.filename !== 'string' ? '' : name.filename;\n      namesLen += 4 + Buffer.byteLength(filename);\n      const longname = !name || !name.longname || typeof name.longname !== 'string' ? '' : name.longname;\n      namesLen += 4 + Buffer.byteLength(longname);\n      if (typeof name.attrs === 'object' && name.attrs !== null) {\n        nameAttrs = attrsToBytes(name.attrs);\n        namesLen += 4 + nameAttrs.nb;\n        if (nameAttrs.nb) {\n          let bytes;\n          if (nameAttrs.nb === ATTRS_BUF.length) {\n            bytes = new Uint8Array(ATTRS_BUF);\n          } else {\n            bytes = new Uint8Array(nameAttrs.nb);\n            bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);\n          }\n          nameAttrs.bytes = bytes;\n        }\n        attrs.push(nameAttrs);\n      } else {\n        namesLen += 4;\n        attrs.push(null);\n      }\n    }\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.NAME;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, count, p);\n    p += 4;\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      {\n        const filename = !name || !name.filename || typeof name.filename !== 'string' ? '' : name.filename;\n        const len = Buffer.byteLength(filename);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(filename, p, len);\n          p += len;\n        }\n      }\n      {\n        const longname = !name || !name.longname || typeof name.longname !== 'string' ? '' : name.longname;\n        const len = Buffer.byteLength(longname);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(longname, p, len);\n          p += len;\n        }\n      }\n      const attr = attrs[i];\n      if (attr) {\n        writeUInt32BE(buf, attr.flags, p);\n        p += 4;\n        if (attr.flags && attr.bytes) {\n          buf.set(attr.bytes, p);\n          p += attr.nb;\n        }\n      } else {\n        writeUInt32BE(buf, 0, p);\n        p += 4;\n      }\n    }\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} NAME`);\n  }\n  attrs(reqid, attrs) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (typeof attrs !== 'object' || attrs === null) throw new Error('attrs is not an object');\n    attrs = attrsToBytes(attrs);\n    const flags = attrs.flags;\n    const attrsLen = attrs.nb;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.ATTRS;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, flags, p);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} ATTRS`);\n  }\n}\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\nfunction read_(self, handle, buf, off, len, position, cb, req_) {\n  const maxDataLen = self._maxReadLen;\n  const overflow = Math.max(len - maxDataLen, 0);\n  if (overflow) len = maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  const handleLen = handle.length;\n  let p = 9;\n  let pos = position;\n  const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  const reqid = self._writeReqid = self._writeReqid + 1 & MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n  writeUInt32BE(out, handleLen, p);\n  out.set(handle, p += 4);\n  p += handleLen;\n  for (let i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n  if (typeof cb !== 'function') cb = noop;\n  const req = req_ || {\n    nb: 0,\n    position,\n    off,\n    origOff: off,\n    len: undefined,\n    overflow: undefined,\n    cb: (err, data, nb) => {\n      const len = req.len;\n      const overflow = req.overflow;\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF) return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      } else if (nb === len && overflow) {\n        req.nb += nb;\n        req.position += nb;\n        req.off += nb;\n        read_(self, handle, buf, req.off, overflow, req.position, cb, req);\n        return;\n      }\n      nb = nb || 0;\n      if (req.origOff === 0 && buf.length === req.nb) data = buf;else data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);\n      cb(undefined, req.nb + nb, data, req.position);\n    },\n    buffer: undefined\n  };\n  req.len = len;\n  req.overflow = overflow;\n\n  // TODO: avoid creating multiple buffer slices when we need to re-call read_()\n  // because of overflow\n  req.buffer = bufferSlice(buf, off, off + len);\n  self._requests[reqid] = req;\n  const isBuffered = sendOrBuffer(self, out);\n  self._debug && self._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READ`);\n}\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  let concurrency = 64;\n  let chunkSize = 32768;\n  let onstep;\n  let mode;\n  let fileSize;\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number' && opts.concurrency > 0 && !isNaN(opts.concurrency)) {\n      concurrency = opts.concurrency;\n    }\n    if (typeof opts.chunkSize === 'number' && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {\n      chunkSize = opts.chunkSize;\n    }\n    if (typeof opts.fileSize === 'number' && opts.fileSize > 0 && !isNaN(opts.fileSize)) {\n      fileSize = opts.fileSize;\n    }\n    if (typeof opts.step === 'function') onstep = opts.step;\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number') mode = modeNum(opts.mode);\n  }\n\n  // Internal state variables\n  let fsize;\n  let pdst = 0;\n  let total = 0;\n  let hadError = false;\n  let srcHandle;\n  let dstHandle;\n  let readbuf;\n  let bufsize = chunkSize * concurrency;\n  function onerror(err) {\n    if (hadError) return;\n    hadError = true;\n    let left = 0;\n    let cbfinal;\n    if (srcHandle || dstHandle) {\n      cbfinal = () => {\n        if (--left === 0) cb(err);\n      };\n      if (srcHandle && (src === fs || src.outgoing.state === 'open')) ++left;\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open')) ++left;\n      if (srcHandle && (src === fs || src.outgoing.state === 'open')) src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open')) dst.close(dstHandle, cbfinal);\n    } else {\n      cb(err);\n    }\n  }\n  src.open(srcPath, 'r', (err, sourceHandle) => {\n    if (err) return onerror(err);\n    srcHandle = sourceHandle;\n    if (fileSize === undefined) src.fstat(srcHandle, tryStat);else tryStat(null, {\n      size: fileSize\n    });\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, (err_, attrs_) => {\n            if (err_) return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n      dst.open(dstPath, 'w', (err, destHandle) => {\n        if (err) return onerror(err);\n        dstHandle = destHandle;\n        if (fsize <= 0) return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error) return onerror(readbuf);\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod()\n              // for whatever reason\n              dst.chmod(dstPath, mode, err_ => tryAgain());\n              return;\n            }\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err) return onerror(err);\n          datapos = datapos || 0;\n          dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n          function writeCb(err) {\n            if (err) return onerror(err);\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n            if (nb < origChunkLen) return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n            if (total === fsize) {\n              dst.close(dstHandle, err => {\n                dstHandle = undefined;\n                if (err) return onerror(err);\n                src.close(srcHandle, err => {\n                  srcHandle = undefined;\n                  if (err) return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n            if (pdst >= fsize) return;\n            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n        function makeCb(psrc, pdst, chunk) {\n          return (err, nb, data) => {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n        function singleRead(psrc, pdst, chunk) {\n          src.read(srcHandle, readbuf, psrc, chunk, pdst, makeCb(psrc, pdst, chunk));\n        }\n        function startReads() {\n          let reads = 0;\n          let psrc = 0;\n          while (pdst < fsize && reads < concurrency) {\n            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\nfunction writeAll(sftp, handle, buffer, offset, length, position, callback_) {\n  const callback = typeof callback_ === 'function' ? callback_ : undefined;\n  sftp.write(handle, buffer, offset, length, position, (writeErr, written) => {\n    if (writeErr) {\n      return sftp.close(handle, () => {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length) {\n      sftp.close(handle, callback);\n    } else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(sftp, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\nclass Stats {\n  constructor(initial) {\n    this.mode = initial && initial.mode;\n    this.uid = initial && initial.uid;\n    this.gid = initial && initial.gid;\n    this.size = initial && initial.size;\n    this.atime = initial && initial.atime;\n    this.mtime = initial && initial.mtime;\n    this.extended = initial && initial.extended;\n  }\n  isDirectory() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFDIR;\n  }\n  isFile() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFREG;\n  }\n  isBlockDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFBLK;\n  }\n  isCharacterDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFCHR;\n  }\n  isSymbolicLink() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFLNK;\n  }\n  isFIFO() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFIFO;\n  }\n  isSocket() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFSOCK;\n  }\n}\nfunction attrsToBytes(attrs) {\n  let flags = 0;\n  let nb = 0;\n  if (typeof attrs === 'object' && attrs !== null) {\n    if (typeof attrs.size === 'number') {\n      flags |= ATTR.SIZE;\n      const val = attrs.size;\n      // Big Endian\n      ATTRS_BUF[nb++] = val / 72057594037927940; // 2**56\n      ATTRS_BUF[nb++] = val / 281474976710656; // 2**48\n      ATTRS_BUF[nb++] = val / 1099511627776; // 2**40\n      ATTRS_BUF[nb++] = val / 4294967296; // 2**32\n      ATTRS_BUF[nb++] = val / 16777216; // 2**24\n      ATTRS_BUF[nb++] = val / 65536; // 2**16\n      ATTRS_BUF[nb++] = val / 256; // 2**8\n      ATTRS_BUF[nb++] = val;\n    }\n    if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n      flags |= ATTR.UIDGID;\n      const uid = attrs.uid;\n      const gid = attrs.gid;\n      // Big Endian\n      ATTRS_BUF[nb++] = uid >>> 24;\n      ATTRS_BUF[nb++] = uid >>> 16;\n      ATTRS_BUF[nb++] = uid >>> 8;\n      ATTRS_BUF[nb++] = uid;\n      ATTRS_BUF[nb++] = gid >>> 24;\n      ATTRS_BUF[nb++] = gid >>> 16;\n      ATTRS_BUF[nb++] = gid >>> 8;\n      ATTRS_BUF[nb++] = gid;\n    }\n    if (typeof attrs.mode === 'number' || typeof attrs.mode === 'string') {\n      const mode = modeNum(attrs.mode);\n      flags |= ATTR.PERMISSIONS;\n      // Big Endian\n      ATTRS_BUF[nb++] = mode >>> 24;\n      ATTRS_BUF[nb++] = mode >>> 16;\n      ATTRS_BUF[nb++] = mode >>> 8;\n      ATTRS_BUF[nb++] = mode;\n    }\n    if ((typeof attrs.atime === 'number' || isDate(attrs.atime)) && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n      const atime = toUnixTimestamp(attrs.atime);\n      const mtime = toUnixTimestamp(attrs.mtime);\n      flags |= ATTR.ACMODTIME;\n      // Big Endian\n      ATTRS_BUF[nb++] = atime >>> 24;\n      ATTRS_BUF[nb++] = atime >>> 16;\n      ATTRS_BUF[nb++] = atime >>> 8;\n      ATTRS_BUF[nb++] = atime;\n      ATTRS_BUF[nb++] = mtime >>> 24;\n      ATTRS_BUF[nb++] = mtime >>> 16;\n      ATTRS_BUF[nb++] = mtime >>> 8;\n      ATTRS_BUF[nb++] = mtime;\n    }\n    // TODO: extended attributes\n  }\n\n  return {\n    flags,\n    nb\n  };\n}\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof time === 'number' && time === time)\n    // Valid, non-NaN number\n    return time;\n  if (isDate(time)) return parseInt(time.getTime() / 1000, 10);\n  throw new Error(`Cannot parse time: ${time}`);\n}\nfunction modeNum(mode) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof mode === 'number' && mode === mode)\n    // Valid, non-NaN number\n    return mode;\n  if (typeof mode === 'string') return modeNum(parseInt(mode, 8));\n  throw new Error(`Cannot parse mode: ${mode}`);\n}\nconst stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL\n};\nfunction stringToFlags(str) {\n  const flags = stringFlagMap[str];\n  return flags !== undefined ? flags : null;\n}\nconst flagsToString = (() => {\n  const stringFlagMapKeys = Object.keys(stringFlagMap);\n  return flags => {\n    for (let i = 0; i < stringFlagMapKeys.length; ++i) {\n      const key = stringFlagMapKeys[i];\n      if (stringFlagMap[key] === flags) return key;\n    }\n    return null;\n  };\n})();\nfunction readAttrs(biOpt) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  const flags = bufferParser.readUInt32BE();\n  if (flags === undefined) return;\n  const attrs = new Stats();\n  if (flags & ATTR.SIZE) {\n    const size = bufferParser.readUInt64BE(biOpt);\n    if (size === undefined) return;\n    attrs.size = size;\n  }\n  if (flags & ATTR.UIDGID) {\n    const uid = bufferParser.readUInt32BE();\n    const gid = bufferParser.readUInt32BE();\n    if (gid === undefined) return;\n    attrs.uid = uid;\n    attrs.gid = gid;\n  }\n  if (flags & ATTR.PERMISSIONS) {\n    const mode = bufferParser.readUInt32BE();\n    if (mode === undefined) return;\n    attrs.mode = mode;\n  }\n  if (flags & ATTR.ACMODTIME) {\n    const atime = bufferParser.readUInt32BE();\n    const mtime = bufferParser.readUInt32BE();\n    if (mtime === undefined) return;\n    attrs.atime = atime;\n    attrs.mtime = mtime;\n  }\n  if (flags & ATTR.EXTENDED) {\n    const count = bufferParser.readUInt32BE();\n    if (count === undefined) return;\n    const extended = {};\n    for (let i = 0; i < count; ++i) {\n      const type = bufferParser.readString(true);\n      const data = bufferParser.readString();\n      if (data === undefined) return;\n      extended[type] = data;\n    }\n    attrs.extended = extended;\n  }\n  return attrs;\n}\nfunction sendOrBuffer(sftp, payload) {\n  const ret = tryWritePayload(sftp, payload);\n  if (ret !== undefined) {\n    sftp._buffer.push(ret);\n    return false;\n  }\n  return true;\n}\nfunction tryWritePayload(sftp, payload) {\n  const outgoing = sftp.outgoing;\n  if (outgoing.state !== 'open') return;\n  if (outgoing.window === 0) {\n    sftp._waitWindow = true;\n    sftp._chunkcb = drainBuffer;\n    return payload;\n  }\n  let ret;\n  const len = payload.length;\n  let p = 0;\n  while (len - p > 0 && outgoing.window > 0) {\n    const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);\n    outgoing.window -= actualLen;\n    if (outgoing.window === 0) {\n      sftp._waitWindow = true;\n      sftp._chunkcb = drainBuffer;\n    }\n    if (p === 0 && actualLen === len) {\n      sftp._protocol.channelData(sftp.outgoing.id, payload);\n    } else {\n      sftp._protocol.channelData(sftp.outgoing.id, bufferSlice(payload, p, p + actualLen));\n    }\n    p += actualLen;\n  }\n  if (len - p > 0) {\n    if (p > 0) ret = bufferSlice(payload, p, len);else ret = payload; // XXX: should never get here?\n  }\n\n  return ret;\n}\nfunction drainBuffer() {\n  this._chunkcb = undefined;\n  const buffer = this._buffer;\n  let i = 0;\n  while (i < buffer.length) {\n    const payload = buffer[i];\n    const ret = tryWritePayload(this, payload);\n    if (ret !== undefined) {\n      if (ret !== payload) buffer[i] = ret;\n      if (i > 0) this._buffer = buffer.slice(i);\n      return;\n    }\n    ++i;\n  }\n  if (i > 0) this._buffer = [];\n}\nfunction doFatalSFTPError(sftp, msg, noDebug) {\n  const err = new Error(msg);\n  err.level = 'sftp-protocol';\n  if (!noDebug && sftp._debug) sftp._debug(`SFTP: Inbound: ${msg}`);\n  sftp.emit('error', err);\n  sftp.destroy();\n  cleanupRequests(sftp);\n  return false;\n}\nfunction cleanupRequests(sftp) {\n  const keys = Object.keys(sftp._requests);\n  if (keys.length === 0) return;\n  const reqs = sftp._requests;\n  sftp._requests = {};\n  const err = new Error('No response from server');\n  for (let i = 0; i < keys.length; ++i) {\n    const req = reqs[keys[i]];\n    if (typeof req.cb === 'function') req.cb(err);\n  }\n}\nfunction requestLimits(sftp, cb) {\n  /*\n    uint32    id\n    string    \"limits@openssh.com\"\n  */\n  let p = 9;\n  const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 18, p);\n  buf.utf8Write('limits@openssh.com', p += 4, 18);\n  sftp._requests[reqid] = {\n    extended: 'limits@openssh.com',\n    cb\n  };\n  const isBuffered = sendOrBuffer(sftp, buf);\n  if (sftp._debug) {\n    const which = isBuffered ? 'Buffered' : 'Sending';\n    sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);\n  }\n}\nconst CLIENT_HANDLERS = {\n  [RESPONSE.VERSION]: (sftp, payload) => {\n    if (sftp._version !== -1) return doFatalSFTPError(sftp, 'Duplicate VERSION packet');\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n    if (version === undefined) return doFatalSFTPError(sftp, 'Malformed VERSION packet');\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version}, exts:${names})`);\n      } else {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);\n      }\n    }\n    sftp._version = version;\n    sftp._extensions = extensions;\n    if (extensions['limits@openssh.com'] === '1') {\n      return requestLimits(sftp, (err, limits) => {\n        if (!err) {\n          if (limits.maxPktLen > 0) sftp._maxOutPktLen = limits.maxPktLen;\n          if (limits.maxReadLen > 0) sftp._maxReadLen = limits.maxReadLen;\n          if (limits.maxWriteLen > 0) sftp._maxWriteLen = limits.maxWriteLen;\n          sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;\n        }\n        sftp.emit('ready');\n      });\n    }\n    sftp.emit('ready');\n  },\n  [RESPONSE.STATUS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      uint32     error/status code\n      string     error message (ISO-10646 UTF-8)\n      string     language tag\n    */\n    const errorCode = bufferParser.readUInt32BE();\n    const errorMsg = bufferParser.readString(true);\n    bufferParser.clear();\n\n    // Note: we avoid checking that the error message and language tag are in\n    // the packet because there are some broken implementations that incorrectly\n    // omit them. The language tag in general was never really used amongst ssh\n    // implementations, so in the case of a missing error message we just\n    // default to something sensible.\n\n    if (sftp._debug) {\n      const jsonMsg = JSON.stringify(errorMsg);\n      sftp._debug(`SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`);\n    }\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') {\n      if (errorCode === STATUS_CODE.OK) {\n        req.cb();\n        return;\n      }\n      const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || 'Unknown status');\n      err.code = errorCode;\n      req.cb(err);\n    }\n  },\n  [RESPONSE.HANDLE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined) {\n      if (reqID !== undefined) delete sftp._requests[reqID];\n      return doFatalSFTPError(sftp, 'Malformed HANDLE packet');\n    }\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') req.cb(undefined, handle);\n  },\n  [RESPONSE.DATA]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      string     data\n    */\n    if (req && typeof req.cb === 'function') {\n      if (req.buffer) {\n        // We have already pre-allocated space to store the data\n\n        const nb = bufferParser.readString(req.buffer);\n        bufferParser.clear();\n        if (nb !== undefined) {\n          sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);\n          req.cb(undefined, req.buffer, nb);\n          return;\n        }\n      } else {\n        const data = bufferParser.readString();\n        bufferParser.clear();\n        if (data !== undefined) {\n          sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`);\n          req.cb(undefined, data);\n          return;\n        }\n      }\n    } else {\n      const nb = bufferParser.skipString();\n      bufferParser.clear();\n      if (nb !== undefined) {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);\n        return;\n      }\n    }\n    return doFatalSFTPError(sftp, 'Malformed DATA packet');\n  },\n  [RESPONSE.NAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      uint32     count\n      repeats count times:\n              string     filename\n              string     longname\n              ATTRS      attrs\n    */\n    const count = bufferParser.readUInt32BE();\n    if (count !== undefined) {\n      let names = [];\n      for (let i = 0; i < count; ++i) {\n        // We are going to assume UTF-8 for filenames despite the SFTPv3\n        // spec not specifying an encoding because the specs for newer\n        // versions of the protocol all explicitly specify UTF-8 for\n        // filenames\n        const filename = bufferParser.readString(true);\n\n        // `longname` only exists in SFTPv3 and since it typically will\n        // contain the filename, we assume it is also UTF-8\n        const longname = bufferParser.readString(true);\n        const attrs = readAttrs(sftp._biOpt);\n        if (attrs === undefined) {\n          names = undefined;\n          break;\n        }\n        names.push({\n          filename,\n          longname,\n          attrs\n        });\n      }\n      if (names !== undefined) {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`);\n        bufferParser.clear();\n        if (req && typeof req.cb === 'function') req.cb(undefined, names);\n        return;\n      }\n    }\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed NAME packet');\n  },\n  [RESPONSE.ATTRS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      ATTRS      attrs\n    */\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs !== undefined) {\n      sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);\n      if (req && typeof req.cb === 'function') req.cb(undefined, attrs);\n      return;\n    }\n    return doFatalSFTPError(sftp, 'Malformed ATTRS packet');\n  },\n  [RESPONSE.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    if (reqID !== undefined) {\n      const req = sftp._requests[reqID];\n      if (req) {\n        delete sftp._requests[reqID];\n        switch (req.extended) {\n          case 'statvfs@openssh.com':\n          case 'fstatvfs@openssh.com':\n            {\n              /*\n                uint64    f_bsize   // file system block size\n                uint64    f_frsize  // fundamental fs block size\n                uint64    f_blocks  // number of blocks (unit f_frsize)\n                uint64    f_bfree   // free blocks in file system\n                uint64    f_bavail  // free blocks for non-root\n                uint64    f_files   // total file inodes\n                uint64    f_ffree   // free file inodes\n                uint64    f_favail  // free file inodes for to non-root\n                uint64    f_fsid    // file system id\n                uint64    f_flag    // bit mask of f_flag values\n                uint64    f_namemax // maximum filename length\n              */\n              const biOpt = sftp._biOpt;\n              const stats = {\n                f_bsize: bufferParser.readUInt64BE(biOpt),\n                f_frsize: bufferParser.readUInt64BE(biOpt),\n                f_blocks: bufferParser.readUInt64BE(biOpt),\n                f_bfree: bufferParser.readUInt64BE(biOpt),\n                f_bavail: bufferParser.readUInt64BE(biOpt),\n                f_files: bufferParser.readUInt64BE(biOpt),\n                f_ffree: bufferParser.readUInt64BE(biOpt),\n                f_favail: bufferParser.readUInt64BE(biOpt),\n                f_sid: bufferParser.readUInt64BE(biOpt),\n                f_flag: bufferParser.readUInt64BE(biOpt),\n                f_namemax: bufferParser.readUInt64BE(biOpt)\n              };\n              if (stats.f_namemax === undefined) break;\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, stats);\n              return;\n            }\n          case 'limits@openssh.com':\n            {\n              /*\n                uint64          max-packet-length\n                uint64          max-read-length\n                uint64          max-write-length\n                uint64          max-open-handles\n              */\n              const limits = {\n                maxPktLen: bufferParser.readUInt64BE(),\n                maxReadLen: bufferParser.readUInt64BE(),\n                maxWriteLen: bufferParser.readUInt64BE(),\n                maxOpenHandles: bufferParser.readUInt64BE()\n              };\n              if (limits.maxOpenHandles === undefined) break;\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, limits);\n              return;\n            }\n          default:\n            // Unknown extended request\n            sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);\n            bufferParser.clear();\n            if (typeof req.cb === 'function') req.cb();\n            return;\n        }\n      } else {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);\n        bufferParser.clear();\n        return;\n      }\n    }\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed EXTENDED_REPLY packet');\n  }\n};\nconst SERVER_HANDLERS = {\n  [REQUEST.INIT]: (sftp, payload) => {\n    if (sftp._version !== -1) return doFatalSFTPError(sftp, 'Duplicate INIT packet');\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n    if (version === undefined) return doFatalSFTPError(sftp, 'Malformed INIT packet');\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version}, exts:${names})`);\n      } else {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);\n      }\n    }\n    sendOrBuffer(sftp, SERVER_VERSION_BUFFER);\n    sftp._version = version;\n    sftp._extensions = extensions;\n    sftp.emit('ready');\n  },\n  [REQUEST.OPEN]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const filename = bufferParser.readString(true);\n    const pflags = bufferParser.readUInt32BE();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed OPEN packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);\n    if (!sftp.emit('OPEN', reqID, filename, pflags, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.CLOSE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed CLOSE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);\n    if (!sftp.emit('CLOSE', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READ]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      uint32     len\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const len = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (len === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed READ packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);\n    if (!sftp.emit('READ', reqID, handle, offset, len)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.WRITE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const data = bufferParser.readString();\n    bufferParser.clear();\n    if (data === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed WRITE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);\n    if (!sftp.emit('WRITE', reqID, handle, offset, data)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.LSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed LSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);\n    if (!sftp.emit('LSTAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed FSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);\n    if (!sftp.emit('FSTAT', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed SETSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);\n    if (!sftp.emit('SETSTAT', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      ATTRS      attrs\n    */\n    const handle = bufferParser.readString();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed FSETSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSETSTAT (id:${reqID})`);\n    if (!sftp.emit('FSETSTAT', reqID, handle, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.OPENDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed OPENDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);\n    if (!sftp.emit('OPENDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed READDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);\n    if (!sftp.emit('READDIR', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REMOVE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed REMOVE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);\n    if (!sftp.emit('REMOVE', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.MKDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed MKDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);\n    if (!sftp.emit('MKDIR', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RMDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed RMDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);\n    if (!sftp.emit('RMDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REALPATH]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed REALPATH packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REALPATH (id:${reqID})`);\n    if (!sftp.emit('REALPATH', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.STAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed STAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);\n    if (!sftp.emit('STAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RENAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     oldpath\n      string     newpath\n    */\n    const oldPath = bufferParser.readString(true);\n    const newPath = bufferParser.readString(true);\n    bufferParser.clear();\n    if (newPath === undefined) return doFatalSFTPError(sftp, 'Malformed RENAME packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);\n    if (!sftp.emit('RENAME', reqID, oldPath, newPath)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed READLINK packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READLINK (id:${reqID})`);\n    if (!sftp.emit('READLINK', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SYMLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     linkpath\n      string     targetpath\n    */\n    const linkPath = bufferParser.readString(true);\n    const targetPath = bufferParser.readString(true);\n    bufferParser.clear();\n    if (targetPath === undefined) return doFatalSFTPError(sftp, 'Malformed SYMLINK packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);\n    let handled;\n    if (sftp._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      handled = sftp.emit('SYMLINK', reqID, targetPath, linkPath);\n    } else {\n      handled = sftp.emit('SYMLINK', reqID, linkPath, targetPath);\n    }\n    if (!handled) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     extended-request\n      ... any request-specific data ...\n    */\n    const extName = bufferParser.readString(true);\n    if (extName === undefined) {\n      bufferParser.clear();\n      return doFatalSFTPError(sftp, 'Malformed EXTENDED packet');\n    }\n    let extData;\n    if (bufferParser.avail()) extData = bufferParser.readRaw();\n    bufferParser.clear();\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED (id:${reqID})`);\n    if (!sftp.emit('EXTENDED', reqID, extName, extData)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  }\n};\n\n// =============================================================================\n// ReadStream/WriteStream-related ==============================================\n// =============================================================================\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  validateNumber\n} = require('./node-fs-compat');\nconst kMinPoolSpace = 128;\nlet pool;\n// It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\nconst poolFragments = [];\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0) pool = poolFragments.pop();else pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n// Check the `this.start` and `this.end` of stream.\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos)) throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n  if (pos < 0) throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\nfunction roundUpToMultipleOf8(n) {\n  return n + 7 & ~7; // Align to 8 byte boundary.\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined) options = {};else if (typeof options === 'string') options = {\n    encoding: options\n  };else if (options === null || typeof options !== 'object') throw new TypeError('\"options\" argument must be a string or an object');else options = Object.create(options);\n\n  // A little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  ReadableStream.call(this, options);\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.isClosed = false;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n    this.pos = this.start;\n  }\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE('start', `<= \"end\" (here: ${this.end})`, this.start);\n    }\n  }\n  this.on('end', function () {\n    if (this.autoClose) this.destroy();\n  });\n  if (!Buffer.isBuffer(this.handle)) this.open();\n}\ninherits(ReadStream, ReadableStream);\nReadStream.prototype.open = function () {\n  if (this._opening) return;\n  this._opening = true;\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready');\n    // Start the flow of data.\n    this.read();\n  });\n};\nReadStream.prototype._read = function (n) {\n  if (!Buffer.isBuffer(this.handle)) return this.once('open', () => this._read(n));\n\n  // XXX: safe to remove this?\n  if (this.destroyed) return;\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // Discard the old pool.\n    allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  const thisPool = pool;\n  let toRead = Math.min(pool.length - pool.used, n);\n  const start = pool.used;\n  if (this.end !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // Already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0) return this.push(null);\n\n  // the actual read.\n  this.sftp.read(this.handle, pool, pool.used, toRead, this.pos, (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n    let b = null;\n\n    // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      const alignedEnd = start + toRead & ~7;\n      const alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace) poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    }\n\n    // Move the pool positions, and internal position for reading.\n    this.pos += bytesRead;\n    this.push(b);\n  });\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\nReadStream.prototype._destroy = function (err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle) return onclose();\n  stream.sftp.close(stream.handle, onclose);\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.isClosed = true;\n    if (!er) stream.emit('close');\n  }\n}\nReadStream.prototype.close = function (cb) {\n  this.destroy(null, cb);\n};\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n\n// TODO: add `concurrency` setting to allow more than one in-flight WRITE\n// request to server to improve throughput\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined) options = {};else if (typeof options === 'string') options = {\n    encoding: options\n  };else if (options === null || typeof options !== 'object') throw new TypeError('\"options\" argument must be a string or an object');else options = Object.create(options);\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  WritableStream.call(this, options);\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.isClosed = false;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n    this.pos = this.start;\n  }\n  if (options.encoding) this.setDefaultEncoding(options.encoding);\n\n  // Node v6.x only\n  this.on('finish', function () {\n    if (this._writableState.finalCalled) return;\n    if (this.autoClose) this.destroy();\n  });\n  if (!Buffer.isBuffer(this.handle)) this.open();\n}\ninherits(WriteStream, WritableStream);\nWriteStream.prototype._final = function (cb) {\n  if (this.autoClose) this.destroy();\n  cb();\n};\nWriteStream.prototype.open = function () {\n  if (this._opening) return;\n  this._opening = true;\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n    this.handle = handle;\n    const tryAgain = err => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, err_ => tryAgain());\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (this.flags[0] === 'a') {\n        const tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\nWriteStream.prototype._write = function (data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function () {\n      this._write(data, encoding, cb);\n    });\n  }\n  this.sftp.write(this.handle, data, 0, data.length, this.pos, (er, bytes) => {\n    if (er) {\n      if (this.autoClose) this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n  this.pos += data.length;\n};\nWriteStream.prototype._writev = function (data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function () {\n      this._writev(data, cb);\n    });\n  }\n  const sftp = this.sftp;\n  const handle = this.handle;\n  let writesLeft = data.length;\n  const onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0) cb();\n  };\n\n  // TODO: try to combine chunks to reduce number of requests to the server?\n  for (let i = 0; i < data.length; ++i) {\n    const chunk = data[i].chunk;\n    sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\nif (typeof WritableStream.prototype.destroy !== 'function') WriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = function (cb) {\n  if (cb) {\n    if (this.isClosed) {\n      process.nextTick(cb);\n      return;\n    }\n    this.on('close', cb);\n  }\n\n  // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n  if (!this.autoClose) this.on('finish', this.destroy.bind(this));\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n// =============================================================================\n\nmodule.exports = {\n  flagsToString,\n  OPEN_MODE,\n  SFTP,\n  Stats,\n  STATUS_CODE,\n  stringToFlags\n};","map":{"version":3,"names":["EventEmitter","require","fs","constants","Readable","ReadableStream","Writable","WritableStream","inherits","isDate","FastBuffer","Buffer","Symbol","species","bufferCopy","bufferSlice","makeBufferParser","writeUInt32BE","ATTR","SIZE","UIDGID","PERMISSIONS","ACMODTIME","EXTENDED","ATTRS_BUF","alloc","STATUS_CODE","OK","EOF","NO_SUCH_FILE","PERMISSION_DENIED","FAILURE","BAD_MESSAGE","NO_CONNECTION","CONNECTION_LOST","OP_UNSUPPORTED","VALID_STATUS_CODES","Map","Object","values","map","n","STATUS_CODE_STR","REQUEST","INIT","OPEN","CLOSE","READ","WRITE","LSTAT","FSTAT","SETSTAT","FSETSTAT","OPENDIR","READDIR","REMOVE","MKDIR","RMDIR","REALPATH","STAT","RENAME","READLINK","SYMLINK","RESPONSE","VERSION","STATUS","HANDLE","DATA","NAME","ATTRS","OPEN_MODE","APPEND","CREAT","TRUNC","EXCL","PKT_RW_OVERHEAD","MAX_REQID","CLIENT_VERSION_BUFFER","from","SERVER_VERSION_BUFFER","RE_OPENSSH","OPENSSH_MAX_PKT_LEN","bufferParser","fakeStderr","readable","writable","push","data","once","on","emit","end","noop","SFTP","constructor","client","chanInfo","cfg","remoteIdentRaw","_protocol","_remoteIdentRaw","server","_debug","debug","undefined","_isOpenSSH","test","_version","_extensions","_biOpt","biOpt","_pktLenBytes","_pktLen","_pktPos","_pktType","_pktData","_writeReqid","_requests","_maxInPktLen","_maxOutPktLen","_maxReadLen","_maxWriteLen","maxOpenHandles","_client","_callbacks","_hasX11","_exit","code","signal","dump","desc","_waitWindow","_chunkcb","_buffer","type","subtype","incoming","outgoing","stderr","cleanupRequests","p","length","nb","Math","min","doFatalSFTPError","max","_pkt","buffer","byteOffset","allocUnsafe","set","Uint8Array","payload","handler","SERVER_HANDLERS","CLIENT_HANDLERS","destroy","state","channelClose","id","_init","sendOrBuffer","createReadStream","path","options","Error","ReadStream","createWriteStream","WriteStream","open","flags_","attrs","cb","flags","stringToFlags","attrsFlags","attrsLen","mode","attrsToBytes","pathLen","byteLength","buf","reqid","utf8Write","isBuffered","close","handle","isBuffer","handleLen","read","off","len","position","read_","readData","write","process","nextTick","maxDataLen","overflow","origPosition","out","i","err","isSent","how","writeData","fastGet","remotePath","localPath","opts","fastXfer","fastPut","readFile","callback_","callback","encoding","flag","TypeError","isEncoding","size","buffers","pos","bytesRead","afterRead","er","nbytes","eof","_wantEOFError","concat","toString","handle_","tryStat","st","stat","er_","st_","fstat","writeFile","openErr","writeAll","appendFile","assign","exists","unlink","filename","fnameLen","rename","oldPath","newPath","oldLen","newLen","mkdir","rmdir","readdir","where","doFilter","full","entries","e","reread","list","opendir","splice","lstat","setstat","fsetstat","futimes","atime","mtime","toUnixTimestamp","utimes","fchown","uid","gid","chown","fchmod","chmod","readlink","names","symlink","targetPath","linkPath","linkLen","targetLen","realpath","ext_openssh_rename","ext","which","ext_openssh_statvfs","extended","ext_openssh_fstatvfs","ext_openssh_hardlink","ext_openssh_fsync","ext_openssh_lsetstat","status","ext_openssh_expandPath","ext_copy_data","srcHandle","srcOffset","dstHandle","dstOffset","message","has","msgLen","isUTF8","dataLen","name","Array","isArray","count","namesLen","nameAttrs","longname","bytes","attr","tryCreateBuffer","ex","self","req_","req","origOff","src","dst","srcPath","dstPath","concurrency","chunkSize","onstep","fileSize","isNaN","step","modeNum","fsize","pdst","total","hadError","readbuf","bufsize","onerror","left","cbfinal","sourceHandle","err_","attrs_","destHandle","tryAgain","startReads","onread","dstpos","datapos","origChunkLen","writeCb","singleRead","chunk","makeCb","psrc","reads","sftp","offset","writeErr","written","Stats","initial","isDirectory","S_IFMT","S_IFDIR","isFile","S_IFREG","isBlockDevice","S_IFBLK","isCharacterDevice","S_IFCHR","isSymbolicLink","S_IFLNK","isFIFO","S_IFIFO","isSocket","S_IFSOCK","val","time","parseInt","getTime","stringFlagMap","str","flagsToString","stringFlagMapKeys","keys","key","readAttrs","readUInt32BE","readUInt64BE","readString","ret","tryWritePayload","window","drainBuffer","actualLen","packetSize","channelData","slice","msg","noDebug","level","reqs","requestLimits","extensions","init","version","avail","extName","extData","clear","limits","maxPktLen","maxReadLen","maxWriteLen","Infinity","reqID","errorCode","errorMsg","jsonMsg","JSON","stringify","skipString","stats","f_bsize","f_frsize","f_blocks","f_bfree","f_bavail","f_files","f_ffree","f_favail","f_sid","f_flag","f_namemax","pflags","handled","readRaw","ERR_INVALID_ARG_TYPE","ERR_OUT_OF_RANGE","validateNumber","kMinPoolSpace","pool","poolFragments","allocNewPool","poolSize","pop","used","checkPosition","Number","isSafeInteger","isInteger","roundUpToMultipleOf8","create","highWaterMark","emitClose","autoDestroy","call","start","autoClose","isClosed","_opening","prototype","_read","destroyed","readableHighWaterMark","_readableState","thisPool","toRead","b","alignedEnd","alignedStart","_destroy","closeStream","bind","stream","onclose","defineProperty","get","configurable","bytesWritten","setDefaultEncoding","_writableState","finalCalled","_final","_write","_writev","writesLeft","onwrite","destroySoon","module","exports"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/protocol/SFTP.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst fs = require('fs');\nconst { constants } = fs;\nconst {\n  Readable: ReadableStream,\n  Writable: WritableStream\n} = require('stream');\nconst { inherits, isDate } = require('util');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst {\n  bufferCopy,\n  bufferSlice,\n  makeBufferParser,\n  writeUInt32BE,\n} = require('./utils.js');\n\nconst ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000,\n};\n\n// Large enough to store all possible attributes\nconst ATTRS_BUF = Buffer.alloc(28);\n\nconst STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\n\nconst VALID_STATUS_CODES = new Map(\n  Object.values(STATUS_CODE).map((n) => [n, 1])\n);\n\nconst STATUS_CODE_STR = {\n  [STATUS_CODE.OK]: 'No error',\n  [STATUS_CODE.EOF]: 'End of file',\n  [STATUS_CODE.NO_SUCH_FILE]: 'No such file or directory',\n  [STATUS_CODE.PERMISSION_DENIED]: 'Permission denied',\n  [STATUS_CODE.FAILURE]: 'Failure',\n  [STATUS_CODE.BAD_MESSAGE]: 'Bad message',\n  [STATUS_CODE.NO_CONNECTION]: 'No connection',\n  [STATUS_CODE.CONNECTION_LOST]: 'Connection lost',\n  [STATUS_CODE.OP_UNSUPPORTED]: 'Operation unsupported',\n};\n\nconst REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\n\nconst RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\n\nconst OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\n\nconst PKT_RW_OVERHEAD = 2 * 1024;\nconst MAX_REQID = 2 ** 32 - 1;\nconst CLIENT_VERSION_BUFFER = Buffer.from([\n  0, 0, 0, 5 /* length */,\n    REQUEST.INIT,\n    0, 0, 0, 3 /* version */\n]);\nconst SERVER_VERSION_BUFFER = Buffer.from([\n  0, 0, 0, 5 /* length */,\n    RESPONSE.VERSION,\n    0, 0, 0, 3 /* version */\n]);\n\nconst RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nconst OPENSSH_MAX_PKT_LEN = 256 * 1024;\n\nconst bufferParser = makeBufferParser();\n\nconst fakeStderr = {\n  readable: false,\n  writable: false,\n  push: (data) => {},\n  once: () => {},\n  on: () => {},\n  emit: () => {},\n  end: () => {},\n};\n\nfunction noop() {}\n\n// Emulates enough of `Channel` to be able to be used as a drop-in replacement\n// in order to process incoming data with as little overhead as possible\nclass SFTP extends EventEmitter {\n  constructor(client, chanInfo, cfg) {\n    super();\n\n    if (typeof cfg !== 'object' || !cfg)\n      cfg = {};\n\n    const remoteIdentRaw = client._protocol._remoteIdentRaw;\n\n    this.server = !!cfg.server;\n    this._debug = (typeof cfg.debug === 'function' ? cfg.debug : undefined);\n    this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));\n\n    this._version = -1;\n    this._extensions = {};\n    this._biOpt = cfg.biOpt;\n    this._pktLenBytes = 0;\n    this._pktLen = 0;\n    this._pktPos = 0;\n    this._pktType = 0;\n    this._pktData = undefined;\n    this._writeReqid = -1;\n    this._requests = {};\n    this._maxInPktLen = OPENSSH_MAX_PKT_LEN;\n    this._maxOutPktLen = 34000;\n    this._maxReadLen =\n      (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this._maxWriteLen =\n      (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n\n    this.maxOpenHandles = undefined;\n\n    // Channel compatibility\n    this._client = client;\n    this._protocol = client._protocol;\n    this._callbacks = [];\n    this._hasX11 = false;\n    this._exit = {\n      code: undefined,\n      signal: undefined,\n      dump: undefined,\n      desc: undefined,\n    };\n    this._waitWindow = false; // SSH-level backpressure\n    this._chunkcb = undefined;\n    this._buffer = [];\n    this.type = chanInfo.type;\n    this.subtype = undefined;\n    this.incoming = chanInfo.incoming;\n    this.outgoing = chanInfo.outgoing;\n    this.stderr = fakeStderr;\n    this.readable = true;\n  }\n\n  // This handles incoming data to parse\n  push(data) {\n    if (data === null) {\n      cleanupRequests(this);\n      if (!this.readable)\n        return;\n      // No more incoming data from the remote side\n      this.readable = false;\n      this.emit('end');\n      return;\n    }\n    /*\n        uint32             length\n        byte               type\n        byte[length - 1]   data payload\n    */\n    let p = 0;\n\n    while (p < data.length) {\n      if (this._pktLenBytes < 4) {\n        let nb = Math.min(4 - this._pktLenBytes, data.length - p);\n        this._pktLenBytes += nb;\n\n        while (nb--)\n          this._pktLen = (this._pktLen << 8) + data[p++];\n\n        if (this._pktLenBytes < 4)\n          return;\n        if (this._pktLen === 0)\n          return doFatalSFTPError(this, 'Invalid packet length');\n        if (this._pktLen > this._maxInPktLen) {\n          const max = this._maxInPktLen;\n          return doFatalSFTPError(\n            this,\n            `Packet length ${this._pktLen} exceeds max length of ${max}`\n          );\n        }\n        if (p >= data.length)\n          return;\n      }\n      if (this._pktPos < this._pktLen) {\n        const nb = Math.min(this._pktLen - this._pktPos, data.length - p);\n        if (p !== 0 || nb !== data.length) {\n          if (nb === this._pktLen) {\n            this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);\n          } else {\n            if (!this._pkt)\n              this._pkt = Buffer.allocUnsafe(this._pktLen);\n            this._pkt.set(\n              new Uint8Array(data.buffer, data.byteOffset + p, nb),\n              this._pktPos\n            );\n          }\n        } else if (nb === this._pktLen) {\n          this._pkt = data;\n        } else {\n          if (!this._pkt)\n            this._pkt = Buffer.allocUnsafe(this._pktLen);\n          this._pkt.set(data, this._pktPos);\n        }\n        p += nb;\n        this._pktPos += nb;\n        if (this._pktPos < this._pktLen)\n          return;\n      }\n\n      const type = this._pkt[0];\n      const payload = this._pkt;\n\n      // Prepare for next packet\n      this._pktLen = 0;\n      this._pktLenBytes = 0;\n      this._pkt = undefined;\n      this._pktPos = 0;\n\n      const handler = (this.server\n                       ? SERVER_HANDLERS[type]\n                       : CLIENT_HANDLERS[type]);\n      if (!handler)\n        return doFatalSFTPError(this, `Unknown packet type ${type}`);\n\n      if (this._version === -1) {\n        if (this.server) {\n          if (type !== REQUEST.INIT)\n            return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);\n        } else if (type !== RESPONSE.VERSION) {\n          return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);\n        }\n      }\n\n      if (handler(this, payload) === false)\n        return;\n    }\n  }\n\n  end() {\n    this.destroy();\n  }\n  destroy() {\n    if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {\n      this.outgoing.state = 'closing';\n      this._protocol.channelClose(this.outgoing.id);\n    }\n  }\n  _init() {\n    this._init = noop;\n    if (!this.server)\n      sendOrBuffer(this, CLIENT_VERSION_BUFFER);\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n  createReadStream(path, options) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    return new ReadStream(this, path, options);\n  }\n  createWriteStream(path, options) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    return new WriteStream(this, path, options);\n  }\n  open(path, flags_, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n\n    const flags = (typeof flags_ === 'number' ? flags_ : stringToFlags(flags_));\n    if (flags === null)\n      throw new Error(`Unknown flags string: ${flags_}`);\n\n    let attrsFlags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'string' || typeof attrs === 'number')\n      attrs = { mode: attrs };\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      attrsFlags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32        id\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPEN;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    writeUInt32BE(buf, attrsFlags, p += 4);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPEN`\n    );\n  }\n  close(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.CLOSE;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} CLOSE`\n    );\n  }\n  read(handle, buf, off, len, position, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf))\n      throw new Error('buffer is not a Buffer');\n    if (off >= buf.length)\n      throw new Error('offset is out of bounds');\n    if (off + len > buf.length)\n      throw new Error('length extends beyond buffer');\n    if (position === null)\n      throw new Error('null position currently unsupported');\n\n    read_(this, handle, buf, off, len, position, cb);\n  }\n  readData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.read(handle, buf, off, len, position, cb);\n  }\n  write(handle, buf, off, len, position, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf))\n      throw new Error('buffer is not a Buffer');\n    if (off > buf.length)\n      throw new Error('offset is out of bounds');\n    if (off + len > buf.length)\n      throw new Error('length extends beyond buffer');\n    if (position === null)\n      throw new Error('null position currently unsupported');\n\n    if (!len) {\n      cb && process.nextTick(cb, undefined, 0);\n      return;\n    }\n\n    const maxDataLen = this._maxWriteLen;\n    const overflow = Math.max(len - maxDataLen, 0);\n    const origPosition = position;\n\n    if (overflow)\n      len = maxDataLen;\n\n    /*\n      uint32     id\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);\n\n    writeUInt32BE(out, out.length - 4, 0);\n    out[4] = REQUEST.WRITE;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(out, reqid, 5);\n\n    writeUInt32BE(out, handleLen, p);\n    out.set(handle, p += 4);\n    p += handleLen;\n    for (let i = 7; i >= 0; --i) {\n      out[p + i] = position & 0xFF;\n      position /= 256;\n    }\n    writeUInt32BE(out, len, p += 8);\n    bufferCopy(buf, out, off, off + len, p += 4);\n\n    this._requests[reqid] = {\n      cb: (err) => {\n        if (err) {\n          if (typeof cb === 'function')\n            cb(err);\n        } else if (overflow) {\n          this.write(handle,\n                     buf,\n                     off + len,\n                     overflow,\n                     origPosition + len,\n                     cb);\n        } else if (typeof cb === 'function') {\n          cb(undefined, off + len);\n        }\n      }\n    };\n\n    const isSent = sendOrBuffer(this, out);\n    if (this._debug) {\n      const how = (isSent ? 'Sent' : 'Buffered');\n      this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);\n    }\n  }\n  writeData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.write(handle, buf, off, len, position, cb);\n  }\n  fastGet(remotePath, localPath, opts, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    fastXfer(this, fs, remotePath, localPath, opts, cb);\n  }\n  fastPut(localPath, remotePath, opts, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    fastXfer(fs, this, localPath, remotePath, opts, cb);\n  }\n  readFile(path, options, callback_) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string')\n      options = { encoding: options, flag: 'r' };\n    else if (!options)\n      options = { encoding: null, flag: 'r' };\n    else if (typeof options !== 'object')\n      throw new TypeError('Bad arguments');\n\n    const encoding = options.encoding;\n    if (encoding && !Buffer.isEncoding(encoding))\n      throw new Error(`Unknown encoding: ${encoding}`);\n\n    // First stat the file, so we know the size.\n    let size;\n    let buffer; // Single buffer with file data\n    let buffers; // List for when size is unknown\n    let pos = 0;\n    let handle;\n\n    // SFTPv3 does not support using -1 for read position, so we have to track\n    // read position manually\n    let bytesRead = 0;\n\n    const flag = options.flag || 'r';\n\n    const read = () => {\n      if (size === 0) {\n        buffer = Buffer.allocUnsafe(8192);\n        this.read(handle, buffer, 0, 8192, bytesRead, afterRead);\n      } else {\n        this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);\n      }\n    };\n\n    const afterRead = (er, nbytes) => {\n      let eof;\n      if (er) {\n        eof = (er.code === STATUS_CODE.EOF);\n        if (!eof) {\n          return this.close(handle, () => {\n            return callback && callback(er);\n          });\n        }\n      } else {\n        eof = false;\n      }\n\n      if (eof || (size === 0 && nbytes === 0))\n        return close();\n\n      bytesRead += nbytes;\n      pos += nbytes;\n      if (size !== 0) {\n        if (pos === size)\n          close();\n        else\n          read();\n      } else {\n        // Unknown size, just read until we don't get bytes.\n        buffers.push(bufferSlice(buffer, 0, nbytes));\n        read();\n      }\n    };\n    afterRead._wantEOFError = true;\n\n    const close = () => {\n      this.close(handle, (er) => {\n        if (size === 0) {\n          // Collect the data into the buffers list.\n          buffer = Buffer.concat(buffers, pos);\n        } else if (pos < size) {\n          buffer = bufferSlice(buffer, 0, pos);\n        }\n\n        if (encoding)\n          buffer = buffer.toString(encoding);\n        return callback && callback(er, buffer);\n      });\n    };\n\n    this.open(path, flag, 0o666, (er, handle_) => {\n      if (er)\n        return callback && callback(er);\n      handle = handle_;\n\n      const tryStat = (er, st) => {\n        if (er) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          this.stat(path, (er_, st_) => {\n            if (er_) {\n              return this.close(handle, () => {\n                callback && callback(er);\n              });\n            }\n            tryStat(null, st_);\n          });\n          return;\n        }\n\n        size = st.size || 0;\n        if (size === 0) {\n          // The kernel lies about many files.\n          // Go ahead and try to read some bytes.\n          buffers = [];\n          return read();\n        }\n\n        buffer = Buffer.allocUnsafe(size);\n        read();\n      };\n      this.fstat(handle, tryStat);\n    });\n  }\n  writeFile(path, data, options, callback_) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string')\n      options = { encoding: options, mode: 0o666, flag: 'w' };\n    else if (!options)\n      options = { encoding: 'utf8', mode: 0o666, flag: 'w' };\n    else if (typeof options !== 'object')\n      throw new TypeError('Bad arguments');\n\n    if (options.encoding && !Buffer.isEncoding(options.encoding))\n      throw new Error(`Unknown encoding: ${options.encoding}`);\n\n    const flag = options.flag || 'w';\n    this.open(path, flag, options.mode, (openErr, handle) => {\n      if (openErr) {\n        callback && callback(openErr);\n      } else {\n        const buffer = (Buffer.isBuffer(data)\n                        ? data\n                        : Buffer.from('' + data, options.encoding || 'utf8'));\n        const position = (/a/.test(flag) ? null : 0);\n\n        // SFTPv3 does not support the notion of 'current position'\n        // (null position), so we just attempt to append to the end of the file\n        // instead\n        if (position === null) {\n          const tryStat = (er, st) => {\n            if (er) {\n              // Try stat() for sftp servers that may not support fstat() for\n              // whatever reason\n              this.stat(path, (er_, st_) => {\n                if (er_) {\n                  return this.close(handle, () => {\n                    callback && callback(er);\n                  });\n                }\n                tryStat(null, st_);\n              });\n              return;\n            }\n            writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);\n          };\n          this.fstat(handle, tryStat);\n          return;\n        }\n        writeAll(this, handle, buffer, 0, buffer.length, position, callback);\n      }\n    });\n  }\n  appendFile(path, data, options, callback_) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string')\n      options = { encoding: options, mode: 0o666, flag: 'a' };\n    else if (!options)\n      options = { encoding: 'utf8', mode: 0o666, flag: 'a' };\n    else if (typeof options !== 'object')\n      throw new TypeError('Bad arguments');\n\n    if (!options.flag)\n      options = Object.assign({ flag: 'a' }, options);\n    this.writeFile(path, data, options, callback);\n  }\n  exists(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    this.stat(path, (err) => {\n      cb && cb(err ? false : true);\n    });\n  }\n  unlink(filename, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     filename\n    */\n    const fnameLen = Buffer.byteLength(filename);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REMOVE;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, fnameLen, p);\n    buf.utf8Write(filename, p += 4, fnameLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REMOVE`\n    );\n  }\n  rename(oldPath, newPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     oldpath\n      string     newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RENAME;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, oldLen, p);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RENAME`\n    );\n  }\n  mkdir(path, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.MKDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} MKDIR`\n    );\n  }\n  rmdir(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RMDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RMDIR`\n    );\n  }\n  readdir(where, opts, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    if (typeof opts !== 'object' || opts === null)\n      opts = {};\n\n    const doFilter = (opts && opts.full ? false : true);\n\n    if (!Buffer.isBuffer(where) && typeof where !== 'string')\n      throw new Error('missing directory handle or path');\n\n    if (typeof where === 'string') {\n      const entries = [];\n      let e = 0;\n\n      const reread = (err, handle) => {\n        if (err)\n          return cb(err);\n\n        this.readdir(handle, opts, (err, list) => {\n          const eof = (err && err.code === STATUS_CODE.EOF);\n\n          if (err && !eof)\n            return this.close(handle, () => cb(err));\n\n          if (eof) {\n            return this.close(handle, (err) => {\n              if (err)\n                return cb(err);\n              cb(undefined, entries);\n            });\n          }\n\n          for (let i = 0; i < list.length; ++i, ++e)\n            entries[e] = list[i];\n\n          reread(undefined, handle);\n        });\n      };\n      return this.opendir(where, reread);\n    }\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = where.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(where, p += 4);\n\n    this._requests[reqid] = {\n      cb: (doFilter\n           ? (err, list) => {\n               if (typeof cb !== 'function')\n                 return;\n               if (err)\n                 return cb(err);\n\n               for (let i = list.length - 1; i >= 0; --i) {\n                 if (list[i].filename === '.' || list[i].filename === '..')\n                   list.splice(i, 1);\n               }\n\n               cb(undefined, list);\n             }\n           : cb)\n    };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READDIR`\n    );\n  }\n  fstat(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSTAT`\n    );\n  }\n  stat(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.STAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STAT`\n    );\n  }\n  lstat(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.LSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} LSTAT`\n    );\n  }\n  opendir(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPENDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPENDIR`\n    );\n  }\n  setstat(path, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SETSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SETSTAT`\n    );\n  }\n  fsetstat(handle, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     handle\n      ATTRS      attrs\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSETSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    writeUInt32BE(buf, flags, p += handleLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSETSTAT`\n    );\n  }\n  futimes(handle, atime, mtime, cb) {\n    return this.fsetstat(handle, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  utimes(path, atime, mtime, cb) {\n    return this.setstat(path, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  fchown(handle, uid, gid, cb) {\n    return this.fsetstat(handle, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  chown(path, uid, gid, cb) {\n    return this.setstat(path, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  fchmod(handle, mode, cb) {\n    return this.fsetstat(handle, {\n      mode: mode\n    }, cb);\n  }\n  chmod(path, mode, cb) {\n    return this.setstat(path, {\n      mode: mode\n    }, cb);\n  }\n  readlink(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READLINK;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function')\n          return;\n        if (err)\n          return cb(err);\n        if (!names || !names.length)\n          return cb(new Error('Response missing link info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READLINK`\n    );\n  }\n  symlink(targetPath, linkPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     linkpath\n      string     targetpath\n    */\n    const linkLen = Buffer.byteLength(linkPath);\n    const targetLen = Buffer.byteLength(targetPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SYMLINK;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    if (this._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      writeUInt32BE(buf, targetLen, p);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n      writeUInt32BE(buf, linkLen, p += targetLen);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n    } else {\n      writeUInt32BE(buf, linkLen, p);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n      writeUInt32BE(buf, targetLen, p += linkLen);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SYMLINK`\n    );\n  }\n  realpath(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REALPATH;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function')\n          return;\n        if (err)\n          return cb(err);\n        if (!names || !names.length)\n          return cb(new Error('Response missing path info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REALPATH`\n    );\n  }\n  // extended requests\n  ext_openssh_rename(oldPath, newPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['posix-rename@openssh.com'];\n    if (!ext || ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"posix-rename@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf =\n      Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 24, p);\n    buf.utf8Write('posix-rename@openssh.com', p += 4, 24);\n    writeUInt32BE(buf, oldLen, p += 24);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);\n    }\n  }\n  ext_openssh_statvfs(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['statvfs@openssh.com'];\n    if (!ext || ext !== '2')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"statvfs@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 19, p);\n    buf.utf8Write('statvfs@openssh.com', p += 4, 19);\n    writeUInt32BE(buf, pathLen, p += 19);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { extended: 'statvfs@openssh.com', cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);\n    }\n  }\n  ext_openssh_fstatvfs(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['fstatvfs@openssh.com'];\n    if (!ext || ext !== '2')\n      throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fstatvfs@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('fstatvfs@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, handleLen, p += 20);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { extended: 'fstatvfs@openssh.com', cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);\n    }\n  }\n  ext_openssh_hardlink(oldPath, newPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['hardlink@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"hardlink@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf =\n      Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('hardlink@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, oldLen, p += 20);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);\n    }\n  }\n  ext_openssh_fsync(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['fsync@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fsync@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 17, p);\n    buf.utf8Write('fsync@openssh.com', p += 4, 17);\n    writeUInt32BE(buf, handleLen, p += 17);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} fsync@openssh.com`\n    );\n  }\n  ext_openssh_lsetstat(path, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['lsetstat@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32    id\n      string    \"lsetstat@openssh.com\"\n      string    path\n      ATTRS     attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf =\n      Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('lsetstat@openssh.com', p += 4, 20);\n\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);\n    }\n  }\n  ext_openssh_expandPath(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['expand-path@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"expand-path@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 23, p);\n    buf.utf8Write('expand-path@openssh.com', p += 4, 23);\n\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);\n    }\n  }\n  ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['copy-data'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    if (!Buffer.isBuffer(srcHandle))\n      throw new Error('Source handle is not a Buffer');\n\n    if (!Buffer.isBuffer(dstHandle))\n      throw new Error('Destination handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"copy-data\"\n      string    read-from-handle\n      uint64    read-from-offset\n      uint64    read-data-length\n      string    write-to-handle\n      uint64    write-to-offset\n    */\n    let p = 0;\n    const buf = Buffer.allocUnsafe(\n      4 + 1\n      + 4\n      + 4 + 9\n      + 4 + srcHandle.length\n      + 8\n      + 8\n      + 4 + dstHandle.length\n      + 8\n    );\n\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n\n    writeUInt32BE(buf, 9, p);\n    p += 4;\n    buf.utf8Write('copy-data', p, 9);\n    p += 9;\n\n    writeUInt32BE(buf, srcHandle.length, p);\n    p += 4;\n    buf.set(srcHandle, p);\n    p += srcHandle.length;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = srcOffset & 0xFF;\n      srcOffset /= 256;\n    }\n    p += 8;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = len & 0xFF;\n      len /= 256;\n    }\n    p += 8;\n\n    writeUInt32BE(buf, dstHandle.length, p);\n    p += 4;\n    buf.set(dstHandle, p);\n    p += dstHandle.length;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = dstOffset & 0xFF;\n      dstOffset /= 256;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${status} copy-data`);\n    }\n  }\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n  handle(reqid, handle) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    const handleLen = handle.length;\n\n    if (handleLen > 256)\n      throw new Error('handle too large (> 256 bytes)');\n\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.HANDLE;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    if (handleLen)\n      buf.set(handle, p += 4);\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} HANDLE`\n    );\n  }\n  status(reqid, code, message) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (!VALID_STATUS_CODES.has(code))\n      throw new Error(`Bad status code: ${code}`);\n\n    message || (message = '');\n\n    const msgLen = Buffer.byteLength(message);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.STATUS;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, code, p);\n\n    writeUInt32BE(buf, msgLen, p += 4);\n    p += 4;\n    if (msgLen) {\n      buf.utf8Write(message, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(buf, 0, p); // Empty language tag\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STATUS`\n    );\n  }\n  data(reqid, data, encoding) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    const isBuffer = Buffer.isBuffer(data);\n\n    if (!isBuffer && typeof data !== 'string')\n      throw new Error('data is not a Buffer or string');\n\n    let isUTF8;\n    if (!isBuffer && !encoding) {\n      encoding = undefined;\n      isUTF8 = true;\n    }\n\n    const dataLen = (\n      isBuffer\n      ? data.length\n      : Buffer.byteLength(data, encoding)\n    );\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.DATA;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, dataLen, p);\n    if (dataLen) {\n      if (isBuffer)\n        buf.set(data, p += 4);\n      else if (isUTF8)\n        buf.utf8Write(data, p += 4, dataLen);\n      else\n        buf.write(data, p += 4, dataLen, encoding);\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} DATA`\n    );\n  }\n  name(reqid, names) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (!Array.isArray(names)) {\n      if (typeof names !== 'object' || names === null)\n        throw new Error('names is not an object or array');\n      names = [ names ];\n    }\n\n    const count = names.length;\n    let namesLen = 0;\n    let nameAttrs;\n    const attrs = [];\n\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      const filename = (\n        !name || !name.filename || typeof name.filename !== 'string'\n        ? ''\n        : name.filename\n      );\n      namesLen += 4 + Buffer.byteLength(filename);\n      const longname = (\n        !name || !name.longname || typeof name.longname !== 'string'\n        ? ''\n        : name.longname\n      );\n      namesLen += 4 + Buffer.byteLength(longname);\n\n      if (typeof name.attrs === 'object' && name.attrs !== null) {\n        nameAttrs = attrsToBytes(name.attrs);\n        namesLen += 4 + nameAttrs.nb;\n\n        if (nameAttrs.nb) {\n          let bytes;\n\n          if (nameAttrs.nb === ATTRS_BUF.length) {\n            bytes = new Uint8Array(ATTRS_BUF);\n          } else {\n            bytes = new Uint8Array(nameAttrs.nb);\n            bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);\n          }\n\n          nameAttrs.bytes = bytes;\n        }\n\n        attrs.push(nameAttrs);\n      } else {\n        namesLen += 4;\n        attrs.push(null);\n      }\n    }\n\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.NAME;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, count, p);\n\n    p += 4;\n\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n\n      {\n        const filename = (\n          !name || !name.filename || typeof name.filename !== 'string'\n          ? ''\n          : name.filename\n        );\n        const len = Buffer.byteLength(filename);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(filename, p, len);\n          p += len;\n        }\n      }\n\n      {\n        const longname = (\n          !name || !name.longname || typeof name.longname !== 'string'\n          ? ''\n          : name.longname\n        );\n        const len = Buffer.byteLength(longname);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(longname, p, len);\n          p += len;\n        }\n      }\n\n      const attr = attrs[i];\n      if (attr) {\n        writeUInt32BE(buf, attr.flags, p);\n        p += 4;\n        if (attr.flags && attr.bytes) {\n          buf.set(attr.bytes, p);\n          p += attr.nb;\n        }\n      } else {\n        writeUInt32BE(buf, 0, p);\n        p += 4;\n      }\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} NAME`\n    );\n  }\n  attrs(reqid, attrs) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (typeof attrs !== 'object' || attrs === null)\n      throw new Error('attrs is not an object');\n\n    attrs = attrsToBytes(attrs);\n    const flags = attrs.flags;\n    const attrsLen = attrs.nb;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.ATTRS;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, flags, p);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} ATTRS`\n    );\n  }\n}\n\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\n\nfunction read_(self, handle, buf, off, len, position, cb, req_) {\n  const maxDataLen = self._maxReadLen;\n  const overflow = Math.max(len - maxDataLen, 0);\n\n  if (overflow)\n    len = maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  const handleLen = handle.length;\n  let p = 9;\n  let pos = position;\n  const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);\n\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  const reqid = self._writeReqid = (self._writeReqid + 1) & MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n\n  writeUInt32BE(out, handleLen, p);\n  out.set(handle, p += 4);\n  p += handleLen;\n  for (let i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n\n  if (typeof cb !== 'function')\n    cb = noop;\n\n  const req = (req_ || {\n    nb: 0,\n    position,\n    off,\n    origOff: off,\n    len: undefined,\n    overflow: undefined,\n    cb: (err, data, nb) => {\n      const len = req.len;\n      const overflow = req.overflow;\n\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)\n          return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      } else if (nb === len && overflow) {\n        req.nb += nb;\n        req.position += nb;\n        req.off += nb;\n        read_(self, handle, buf, req.off, overflow, req.position, cb, req);\n        return;\n      }\n\n      nb = (nb || 0);\n      if (req.origOff === 0 && buf.length === req.nb)\n        data = buf;\n      else\n        data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);\n      cb(undefined, req.nb + nb, data, req.position);\n    },\n    buffer: undefined,\n  });\n\n  req.len = len;\n  req.overflow = overflow;\n\n  // TODO: avoid creating multiple buffer slices when we need to re-call read_()\n  // because of overflow\n  req.buffer = bufferSlice(buf, off, off + len);\n\n  self._requests[reqid] = req;\n\n  const isBuffered = sendOrBuffer(self, out);\n  self._debug && self._debug(\n    `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READ`\n  );\n}\n\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  let concurrency = 64;\n  let chunkSize = 32768;\n  let onstep;\n  let mode;\n  let fileSize;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number'\n        && opts.concurrency > 0\n        && !isNaN(opts.concurrency)) {\n      concurrency = opts.concurrency;\n    }\n    if (typeof opts.chunkSize === 'number'\n        && opts.chunkSize > 0\n        && !isNaN(opts.chunkSize)) {\n      chunkSize = opts.chunkSize;\n    }\n    if (typeof opts.fileSize === 'number'\n        && opts.fileSize > 0\n        && !isNaN(opts.fileSize)) {\n      fileSize = opts.fileSize;\n    }\n    if (typeof opts.step === 'function')\n      onstep = opts.step;\n\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number')\n      mode = modeNum(opts.mode);\n  }\n\n  // Internal state variables\n  let fsize;\n  let pdst = 0;\n  let total = 0;\n  let hadError = false;\n  let srcHandle;\n  let dstHandle;\n  let readbuf;\n  let bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError)\n      return;\n\n    hadError = true;\n\n    let left = 0;\n    let cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = () => {\n        if (--left === 0)\n          cb(err);\n      };\n      if (srcHandle && (src === fs || src.outgoing.state === 'open'))\n        ++left;\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open'))\n        ++left;\n      if (srcHandle && (src === fs || src.outgoing.state === 'open'))\n        src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open'))\n        dst.close(dstHandle, cbfinal);\n    } else {\n      cb(err);\n    }\n  }\n\n  src.open(srcPath, 'r', (err, sourceHandle) => {\n    if (err)\n      return onerror(err);\n\n    srcHandle = sourceHandle;\n\n    if (fileSize === undefined)\n      src.fstat(srcHandle, tryStat);\n    else\n      tryStat(null, { size: fileSize });\n\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, (err_, attrs_) => {\n            if (err_)\n              return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n\n      dst.open(dstPath, 'w', (err, destHandle) => {\n        if (err)\n          return onerror(err);\n\n        dstHandle = destHandle;\n\n        if (fsize <= 0)\n          return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error)\n          return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod()\n              // for whatever reason\n              dst.chmod(dstPath, mode, (err_) => tryAgain());\n              return;\n            }\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err)\n            return onerror(err);\n\n          datapos = datapos || 0;\n\n          dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err)\n              return onerror(err);\n\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n\n            if (nb < origChunkLen)\n              return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n\n            if (total === fsize) {\n              dst.close(dstHandle, (err) => {\n                dstHandle = undefined;\n                if (err)\n                  return onerror(err);\n                src.close(srcHandle, (err) => {\n                  srcHandle = undefined;\n                  if (err)\n                    return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n\n            if (pdst >= fsize)\n              return;\n\n            const chunk =\n              (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n\n        function makeCb(psrc, pdst, chunk) {\n          return (err, nb, data) => {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n\n        function singleRead(psrc, pdst, chunk) {\n          src.read(srcHandle,\n                   readbuf,\n                   psrc,\n                   chunk,\n                   pdst,\n                   makeCb(psrc, pdst, chunk));\n        }\n\n        function startReads() {\n          let reads = 0;\n          let psrc = 0;\n          while (pdst < fsize && reads < concurrency) {\n            const chunk =\n              (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\n\nfunction writeAll(sftp, handle, buffer, offset, length, position, callback_) {\n  const callback = (typeof callback_ === 'function' ? callback_ : undefined);\n\n  sftp.write(handle,\n             buffer,\n             offset,\n             length,\n             position,\n             (writeErr, written) => {\n    if (writeErr) {\n      return sftp.close(handle, () => {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length) {\n      sftp.close(handle, callback);\n    } else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(sftp, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\n\nclass Stats {\n  constructor(initial) {\n    this.mode = (initial && initial.mode);\n    this.uid = (initial && initial.uid);\n    this.gid = (initial && initial.gid);\n    this.size = (initial && initial.size);\n    this.atime = (initial && initial.atime);\n    this.mtime = (initial && initial.mtime);\n    this.extended = (initial && initial.extended);\n  }\n  isDirectory() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFDIR);\n  }\n  isFile() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFREG);\n  }\n  isBlockDevice() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFBLK);\n  }\n  isCharacterDevice() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFCHR);\n  }\n  isSymbolicLink() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFLNK);\n  }\n  isFIFO() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFIFO);\n  }\n  isSocket() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFSOCK);\n  }\n}\n\nfunction attrsToBytes(attrs) {\n  let flags = 0;\n  let nb = 0;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    if (typeof attrs.size === 'number') {\n      flags |= ATTR.SIZE;\n      const val = attrs.size;\n      // Big Endian\n      ATTRS_BUF[nb++] = val / 72057594037927940; // 2**56\n      ATTRS_BUF[nb++] = val / 281474976710656; // 2**48\n      ATTRS_BUF[nb++] = val / 1099511627776; // 2**40\n      ATTRS_BUF[nb++] = val / 4294967296; // 2**32\n      ATTRS_BUF[nb++] = val / 16777216; // 2**24\n      ATTRS_BUF[nb++] = val / 65536; // 2**16\n      ATTRS_BUF[nb++] = val / 256; // 2**8\n      ATTRS_BUF[nb++] = val;\n    }\n    if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n      flags |= ATTR.UIDGID;\n      const uid = attrs.uid;\n      const gid = attrs.gid;\n      // Big Endian\n      ATTRS_BUF[nb++] = uid >>> 24;\n      ATTRS_BUF[nb++] = uid >>> 16;\n      ATTRS_BUF[nb++] = uid >>> 8;\n      ATTRS_BUF[nb++] = uid;\n      ATTRS_BUF[nb++] = gid >>> 24;\n      ATTRS_BUF[nb++] = gid >>> 16;\n      ATTRS_BUF[nb++] = gid >>> 8;\n      ATTRS_BUF[nb++] = gid;\n    }\n    if (typeof attrs.mode === 'number' || typeof attrs.mode === 'string') {\n      const mode = modeNum(attrs.mode);\n      flags |= ATTR.PERMISSIONS;\n      // Big Endian\n      ATTRS_BUF[nb++] = mode >>> 24;\n      ATTRS_BUF[nb++] = mode >>> 16;\n      ATTRS_BUF[nb++] = mode >>> 8;\n      ATTRS_BUF[nb++] = mode;\n    }\n    if ((typeof attrs.atime === 'number' || isDate(attrs.atime))\n        && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n      const atime = toUnixTimestamp(attrs.atime);\n      const mtime = toUnixTimestamp(attrs.mtime);\n\n      flags |= ATTR.ACMODTIME;\n      // Big Endian\n      ATTRS_BUF[nb++] = atime >>> 24;\n      ATTRS_BUF[nb++] = atime >>> 16;\n      ATTRS_BUF[nb++] = atime >>> 8;\n      ATTRS_BUF[nb++] = atime;\n      ATTRS_BUF[nb++] = mtime >>> 24;\n      ATTRS_BUF[nb++] = mtime >>> 16;\n      ATTRS_BUF[nb++] = mtime >>> 8;\n      ATTRS_BUF[nb++] = mtime;\n    }\n    // TODO: extended attributes\n  }\n\n  return { flags, nb };\n}\n\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof time === 'number' && time === time) // Valid, non-NaN number\n    return time;\n  if (isDate(time))\n    return parseInt(time.getTime() / 1000, 10);\n  throw new Error(`Cannot parse time: ${time}`);\n}\n\nfunction modeNum(mode) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof mode === 'number' && mode === mode) // Valid, non-NaN number\n    return mode;\n  if (typeof mode === 'string')\n    return modeNum(parseInt(mode, 8));\n  throw new Error(`Cannot parse mode: ${mode}`);\n}\n\nconst stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL\n};\n\nfunction stringToFlags(str) {\n  const flags = stringFlagMap[str];\n  return (flags !== undefined ? flags : null);\n}\n\nconst flagsToString = (() => {\n  const stringFlagMapKeys = Object.keys(stringFlagMap);\n  return (flags) => {\n    for (let i = 0; i < stringFlagMapKeys.length; ++i) {\n      const key = stringFlagMapKeys[i];\n      if (stringFlagMap[key] === flags)\n        return key;\n    }\n    return null;\n  };\n})();\n\nfunction readAttrs(biOpt) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  const flags = bufferParser.readUInt32BE();\n  if (flags === undefined)\n    return;\n\n  const attrs = new Stats();\n  if (flags & ATTR.SIZE) {\n    const size = bufferParser.readUInt64BE(biOpt);\n    if (size === undefined)\n      return;\n    attrs.size = size;\n  }\n\n  if (flags & ATTR.UIDGID) {\n    const uid = bufferParser.readUInt32BE();\n    const gid = bufferParser.readUInt32BE();\n    if (gid === undefined)\n      return;\n    attrs.uid = uid;\n    attrs.gid = gid;\n  }\n\n  if (flags & ATTR.PERMISSIONS) {\n    const mode = bufferParser.readUInt32BE();\n    if (mode === undefined)\n      return;\n    attrs.mode = mode;\n  }\n\n  if (flags & ATTR.ACMODTIME) {\n    const atime = bufferParser.readUInt32BE();\n    const mtime = bufferParser.readUInt32BE();\n    if (mtime === undefined)\n      return;\n    attrs.atime = atime;\n    attrs.mtime = mtime;\n  }\n\n  if (flags & ATTR.EXTENDED) {\n    const count = bufferParser.readUInt32BE();\n    if (count === undefined)\n      return;\n    const extended = {};\n    for (let i = 0; i < count; ++i) {\n      const type = bufferParser.readString(true);\n      const data = bufferParser.readString();\n      if (data === undefined)\n        return;\n      extended[type] = data;\n    }\n    attrs.extended = extended;\n  }\n\n  return attrs;\n}\n\nfunction sendOrBuffer(sftp, payload) {\n  const ret = tryWritePayload(sftp, payload);\n  if (ret !== undefined) {\n    sftp._buffer.push(ret);\n    return false;\n  }\n  return true;\n}\n\nfunction tryWritePayload(sftp, payload) {\n  const outgoing = sftp.outgoing;\n  if (outgoing.state !== 'open')\n    return;\n\n  if (outgoing.window === 0) {\n    sftp._waitWindow = true;\n    sftp._chunkcb = drainBuffer;\n    return payload;\n  }\n\n  let ret;\n  const len = payload.length;\n  let p = 0;\n\n  while (len - p > 0 && outgoing.window > 0) {\n    const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);\n    outgoing.window -= actualLen;\n    if (outgoing.window === 0) {\n      sftp._waitWindow = true;\n      sftp._chunkcb = drainBuffer;\n    }\n\n    if (p === 0 && actualLen === len) {\n      sftp._protocol.channelData(sftp.outgoing.id, payload);\n    } else {\n      sftp._protocol.channelData(sftp.outgoing.id,\n                                 bufferSlice(payload, p, p + actualLen));\n    }\n\n    p += actualLen;\n  }\n\n  if (len - p > 0) {\n    if (p > 0)\n      ret = bufferSlice(payload, p, len);\n    else\n      ret = payload; // XXX: should never get here?\n  }\n\n  return ret;\n}\n\nfunction drainBuffer() {\n  this._chunkcb = undefined;\n  const buffer = this._buffer;\n  let i = 0;\n  while (i < buffer.length) {\n    const payload = buffer[i];\n    const ret = tryWritePayload(this, payload);\n    if (ret !== undefined) {\n      if (ret !== payload)\n        buffer[i] = ret;\n      if (i > 0)\n        this._buffer = buffer.slice(i);\n      return;\n    }\n    ++i;\n  }\n  if (i > 0)\n    this._buffer = [];\n}\n\nfunction doFatalSFTPError(sftp, msg, noDebug) {\n  const err = new Error(msg);\n  err.level = 'sftp-protocol';\n  if (!noDebug && sftp._debug)\n    sftp._debug(`SFTP: Inbound: ${msg}`);\n  sftp.emit('error', err);\n  sftp.destroy();\n  cleanupRequests(sftp);\n  return false;\n}\n\nfunction cleanupRequests(sftp) {\n  const keys = Object.keys(sftp._requests);\n  if (keys.length === 0)\n    return;\n\n  const reqs = sftp._requests;\n  sftp._requests = {};\n  const err = new Error('No response from server');\n  for (let i = 0; i < keys.length; ++i) {\n    const req = reqs[keys[i]];\n    if (typeof req.cb === 'function')\n      req.cb(err);\n  }\n}\n\nfunction requestLimits(sftp, cb) {\n  /*\n    uint32    id\n    string    \"limits@openssh.com\"\n  */\n  let p = 9;\n  const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  const reqid = sftp._writeReqid = (sftp._writeReqid + 1) & MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, 18, p);\n  buf.utf8Write('limits@openssh.com', p += 4, 18);\n\n  sftp._requests[reqid] = { extended: 'limits@openssh.com', cb };\n\n  const isBuffered = sendOrBuffer(sftp, buf);\n  if (sftp._debug) {\n    const which = (isBuffered ? 'Buffered' : 'Sending');\n    sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);\n  }\n}\n\nconst CLIENT_HANDLERS = {\n  [RESPONSE.VERSION]: (sftp, payload) => {\n    if (sftp._version !== -1)\n      return doFatalSFTPError(sftp, 'Duplicate VERSION packet');\n\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n\n    if (version === undefined)\n      return doFatalSFTPError(sftp, 'Malformed VERSION packet');\n\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(\n          `SFTP: Inbound: Received VERSION (v${version}, exts:${names})`\n        );\n      } else {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);\n      }\n    }\n\n    sftp._version = version;\n    sftp._extensions = extensions;\n\n    if (extensions['limits@openssh.com'] === '1') {\n      return requestLimits(sftp, (err, limits) => {\n        if (!err) {\n          if (limits.maxPktLen > 0)\n            sftp._maxOutPktLen = limits.maxPktLen;\n          if (limits.maxReadLen > 0)\n            sftp._maxReadLen = limits.maxReadLen;\n          if (limits.maxWriteLen > 0)\n            sftp._maxWriteLen = limits.maxWriteLen;\n          sftp.maxOpenHandles = (\n            limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity\n          );\n        }\n        sftp.emit('ready');\n      });\n    }\n\n    sftp.emit('ready');\n  },\n  [RESPONSE.STATUS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      uint32     error/status code\n      string     error message (ISO-10646 UTF-8)\n      string     language tag\n    */\n    const errorCode = bufferParser.readUInt32BE();\n    const errorMsg = bufferParser.readString(true);\n    bufferParser.clear();\n\n    // Note: we avoid checking that the error message and language tag are in\n    // the packet because there are some broken implementations that incorrectly\n    // omit them. The language tag in general was never really used amongst ssh\n    // implementations, so in the case of a missing error message we just\n    // default to something sensible.\n\n    if (sftp._debug) {\n      const jsonMsg = JSON.stringify(errorMsg);\n      sftp._debug(\n        `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`\n      );\n    }\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') {\n      if (errorCode === STATUS_CODE.OK) {\n        req.cb();\n        return;\n      }\n      const err = new Error(errorMsg\n                            || STATUS_CODE_STR[errorCode]\n                            || 'Unknown status');\n      err.code = errorCode;\n      req.cb(err);\n    }\n  },\n  [RESPONSE.HANDLE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined) {\n      if (reqID !== undefined)\n        delete sftp._requests[reqID];\n      return doFatalSFTPError(sftp, 'Malformed HANDLE packet');\n    }\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);\n\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function')\n      req.cb(undefined, handle);\n  },\n  [RESPONSE.DATA]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      string     data\n    */\n    if (req && typeof req.cb === 'function') {\n      if (req.buffer) {\n        // We have already pre-allocated space to store the data\n\n        const nb = bufferParser.readString(req.buffer);\n        bufferParser.clear();\n\n        if (nb !== undefined) {\n          sftp._debug && sftp._debug(\n            `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`\n          );\n          req.cb(undefined, req.buffer, nb);\n          return;\n        }\n      } else {\n        const data = bufferParser.readString();\n        bufferParser.clear();\n\n        if (data !== undefined) {\n          sftp._debug && sftp._debug(\n            `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`\n          );\n          req.cb(undefined, data);\n          return;\n        }\n      }\n    } else {\n      const nb = bufferParser.skipString();\n      bufferParser.clear();\n      if (nb !== undefined) {\n        sftp._debug && sftp._debug(\n          `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`\n        );\n        return;\n      }\n    }\n\n    return doFatalSFTPError(sftp, 'Malformed DATA packet');\n  },\n  [RESPONSE.NAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      uint32     count\n      repeats count times:\n              string     filename\n              string     longname\n              ATTRS      attrs\n    */\n    const count = bufferParser.readUInt32BE();\n    if (count !== undefined) {\n      let names = [];\n      for (let i = 0; i < count; ++i) {\n        // We are going to assume UTF-8 for filenames despite the SFTPv3\n        // spec not specifying an encoding because the specs for newer\n        // versions of the protocol all explicitly specify UTF-8 for\n        // filenames\n        const filename = bufferParser.readString(true);\n\n        // `longname` only exists in SFTPv3 and since it typically will\n        // contain the filename, we assume it is also UTF-8\n        const longname = bufferParser.readString(true);\n\n        const attrs = readAttrs(sftp._biOpt);\n        if (attrs === undefined) {\n          names = undefined;\n          break;\n        }\n        names.push({ filename, longname, attrs });\n      }\n      if (names !== undefined) {\n        sftp._debug && sftp._debug(\n          `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`\n        );\n        bufferParser.clear();\n        if (req && typeof req.cb === 'function')\n          req.cb(undefined, names);\n        return;\n      }\n    }\n\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed NAME packet');\n  },\n  [RESPONSE.ATTRS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      ATTRS      attrs\n    */\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs !== undefined) {\n      sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);\n      if (req && typeof req.cb === 'function')\n        req.cb(undefined, attrs);\n      return;\n    }\n\n    return doFatalSFTPError(sftp, 'Malformed ATTRS packet');\n  },\n  [RESPONSE.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    if (reqID !== undefined) {\n      const req = sftp._requests[reqID];\n      if (req) {\n        delete sftp._requests[reqID];\n        switch (req.extended) {\n          case 'statvfs@openssh.com':\n          case 'fstatvfs@openssh.com': {\n            /*\n              uint64    f_bsize   // file system block size\n              uint64    f_frsize  // fundamental fs block size\n              uint64    f_blocks  // number of blocks (unit f_frsize)\n              uint64    f_bfree   // free blocks in file system\n              uint64    f_bavail  // free blocks for non-root\n              uint64    f_files   // total file inodes\n              uint64    f_ffree   // free file inodes\n              uint64    f_favail  // free file inodes for to non-root\n              uint64    f_fsid    // file system id\n              uint64    f_flag    // bit mask of f_flag values\n              uint64    f_namemax // maximum filename length\n            */\n            const biOpt = sftp._biOpt;\n            const stats = {\n              f_bsize: bufferParser.readUInt64BE(biOpt),\n              f_frsize: bufferParser.readUInt64BE(biOpt),\n              f_blocks: bufferParser.readUInt64BE(biOpt),\n              f_bfree: bufferParser.readUInt64BE(biOpt),\n              f_bavail: bufferParser.readUInt64BE(biOpt),\n              f_files: bufferParser.readUInt64BE(biOpt),\n              f_ffree: bufferParser.readUInt64BE(biOpt),\n              f_favail: bufferParser.readUInt64BE(biOpt),\n              f_sid: bufferParser.readUInt64BE(biOpt),\n              f_flag: bufferParser.readUInt64BE(biOpt),\n              f_namemax: bufferParser.readUInt64BE(biOpt),\n            };\n            if (stats.f_namemax === undefined)\n              break;\n            if (sftp._debug) {\n              sftp._debug(\n                'SFTP: Inbound: Received EXTENDED_REPLY '\n                  + `(id:${reqID}, ${req.extended})`\n              );\n            }\n            bufferParser.clear();\n            if (typeof req.cb === 'function')\n              req.cb(undefined, stats);\n            return;\n          }\n          case 'limits@openssh.com': {\n            /*\n              uint64          max-packet-length\n              uint64          max-read-length\n              uint64          max-write-length\n              uint64          max-open-handles\n            */\n            const limits = {\n              maxPktLen: bufferParser.readUInt64BE(),\n              maxReadLen: bufferParser.readUInt64BE(),\n              maxWriteLen: bufferParser.readUInt64BE(),\n              maxOpenHandles: bufferParser.readUInt64BE(),\n            };\n            if (limits.maxOpenHandles === undefined)\n              break;\n            if (sftp._debug) {\n              sftp._debug(\n                'SFTP: Inbound: Received EXTENDED_REPLY '\n                  + `(id:${reqID}, ${req.extended})`\n              );\n            }\n            bufferParser.clear();\n            if (typeof req.cb === 'function')\n              req.cb(undefined, limits);\n            return;\n          }\n          default:\n            // Unknown extended request\n            sftp._debug && sftp._debug(\n              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`\n            );\n            bufferParser.clear();\n            if (typeof req.cb === 'function')\n              req.cb();\n            return;\n        }\n      } else {\n        sftp._debug && sftp._debug(\n          `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`\n        );\n        bufferParser.clear();\n        return;\n      }\n    }\n\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed EXTENDED_REPLY packet');\n  },\n};\nconst SERVER_HANDLERS = {\n  [REQUEST.INIT]: (sftp, payload) => {\n    if (sftp._version !== -1)\n      return doFatalSFTPError(sftp, 'Duplicate INIT packet');\n\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n\n    if (version === undefined)\n      return doFatalSFTPError(sftp, 'Malformed INIT packet');\n\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(\n          `SFTP: Inbound: Received INIT (v${version}, exts:${names})`\n        );\n      } else {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);\n      }\n    }\n\n    sendOrBuffer(sftp, SERVER_VERSION_BUFFER);\n\n    sftp._version = version;\n    sftp._extensions = extensions;\n    sftp.emit('ready');\n  },\n  [REQUEST.OPEN]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const filename = bufferParser.readString(true);\n    const pflags = bufferParser.readUInt32BE();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined)\n      return doFatalSFTPError(sftp, 'Malformed OPEN packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);\n\n    if (!sftp.emit('OPEN', reqID, filename, pflags, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.CLOSE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed CLOSE packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);\n\n    if (!sftp.emit('CLOSE', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READ]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      uint32     len\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const len = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (len === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed READ packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);\n\n    if (!sftp.emit('READ', reqID, handle, offset, len)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.WRITE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const data = bufferParser.readString();\n    bufferParser.clear();\n\n    if (data === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed WRITE packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);\n\n    if (!sftp.emit('WRITE', reqID, handle, offset, data)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.LSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed LSTAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);\n\n    if (!sftp.emit('LSTAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed FSTAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);\n\n    if (!sftp.emit('FSTAT', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined)\n      return doFatalSFTPError(sftp, 'Malformed SETSTAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);\n\n    if (!sftp.emit('SETSTAT', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      ATTRS      attrs\n    */\n    const handle = bufferParser.readString();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed FSETSTAT packet');\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received FSETSTAT (id:${reqID})`\n    );\n\n    if (!sftp.emit('FSETSTAT', reqID, handle, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.OPENDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed OPENDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);\n\n    if (!sftp.emit('OPENDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed READDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);\n\n    if (!sftp.emit('READDIR', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REMOVE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed REMOVE packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);\n\n    if (!sftp.emit('REMOVE', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.MKDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined)\n      return doFatalSFTPError(sftp, 'Malformed MKDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);\n\n    if (!sftp.emit('MKDIR', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RMDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed RMDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);\n\n    if (!sftp.emit('RMDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REALPATH]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed REALPATH packet');\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received REALPATH (id:${reqID})`\n    );\n\n    if (!sftp.emit('REALPATH', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.STAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed STAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);\n\n    if (!sftp.emit('STAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RENAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     oldpath\n      string     newpath\n    */\n    const oldPath = bufferParser.readString(true);\n    const newPath = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (newPath === undefined)\n      return doFatalSFTPError(sftp, 'Malformed RENAME packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);\n\n    if (!sftp.emit('RENAME', reqID, oldPath, newPath)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed READLINK packet');\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received READLINK (id:${reqID})`\n    );\n\n    if (!sftp.emit('READLINK', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SYMLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     linkpath\n      string     targetpath\n    */\n    const linkPath = bufferParser.readString(true);\n    const targetPath = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (targetPath === undefined)\n      return doFatalSFTPError(sftp, 'Malformed SYMLINK packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);\n\n    let handled;\n    if (sftp._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      handled = sftp.emit('SYMLINK', reqID, targetPath, linkPath);\n    } else {\n      handled = sftp.emit('SYMLINK', reqID, linkPath, targetPath);\n    }\n    if (!handled) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     extended-request\n      ... any request-specific data ...\n    */\n    const extName = bufferParser.readString(true);\n    if (extName === undefined) {\n      bufferParser.clear();\n      return doFatalSFTPError(sftp, 'Malformed EXTENDED packet');\n    }\n\n    let extData;\n    if (bufferParser.avail())\n      extData = bufferParser.readRaw();\n    bufferParser.clear();\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received EXTENDED (id:${reqID})`\n    );\n\n    if (!sftp.emit('EXTENDED', reqID, extName, extData)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n};\n\n// =============================================================================\n// ReadStream/WriteStream-related ==============================================\n// =============================================================================\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  validateNumber\n} = require('./node-fs-compat');\n\nconst kMinPoolSpace = 128;\n\nlet pool;\n// It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\nconst poolFragments = [];\n\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0)\n    pool = poolFragments.pop();\n  else\n    pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n// Check the `this.start` and `this.end` of stream.\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n  if (pos < 0)\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\n\nfunction roundUpToMultipleOf8(n) {\n  return (n + 7) & ~7;  // Align to 8 byte boundary.\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // A little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  ReadableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.isClosed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE(\n        'start',\n        `<= \"end\" (here: ${this.end})`,\n        this.start\n      );\n    }\n  }\n\n  this.on('end', function() {\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready');\n    // Start the flow of data.\n    this.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!Buffer.isBuffer(this.handle))\n    return this.once('open', () => this._read(n));\n\n  // XXX: safe to remove this?\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // Discard the old pool.\n    allocNewPool(this.readableHighWaterMark\n                 || this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  const thisPool = pool;\n  let toRead = Math.min(pool.length - pool.used, n);\n  const start = pool.used;\n\n  if (this.end !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // Already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  this.sftp.read(this.handle,\n                 pool,\n                 pool.used,\n                 toRead,\n                 this.pos,\n                 (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n    let b = null;\n\n    // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      const alignedEnd = (start + toRead) & ~7;\n      const alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace)\n        poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    }\n\n    // Move the pool positions, and internal position for reading.\n    this.pos += bytesRead;\n\n    this.push(b);\n  });\n\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\n\nReadStream.prototype._destroy = function(err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\n\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle)\n    return onclose();\n\n  stream.sftp.close(stream.handle, onclose);\n\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.isClosed = true;\n    if (!er)\n      stream.emit('close');\n  }\n}\n\nReadStream.prototype.close = function(cb) {\n  this.destroy(null, cb);\n};\n\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n\n// TODO: add `concurrency` setting to allow more than one in-flight WRITE\n// request to server to improve throughput\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  WritableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.isClosed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  // Node v6.x only\n  this.on('finish', function() {\n    if (this._writableState.finalCalled)\n      return;\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype._final = function(cb) {\n  if (this.autoClose)\n    this.destroy();\n  cb();\n};\n\nWriteStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n\n    const tryAgain = (err) => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (this.flags[0] === 'a') {\n        const tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  this.sftp.write(this.handle,\n                  data,\n                  0,\n                  data.length,\n                  this.pos,\n                  (er, bytes) => {\n    if (er) {\n      if (this.autoClose)\n        this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n  }\n\n  const sftp = this.sftp;\n  const handle = this.handle;\n  let writesLeft = data.length;\n\n  const onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0)\n      cb();\n  };\n\n  // TODO: try to combine chunks to reduce number of requests to the server?\n  for (let i = 0; i < data.length; ++i) {\n    const chunk = data[i].chunk;\n\n    sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\n\nif (typeof WritableStream.prototype.destroy !== 'function')\n  WriteStream.prototype.destroy = ReadStream.prototype.destroy;\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = function(cb) {\n  if (cb) {\n    if (this.isClosed) {\n      process.nextTick(cb);\n      return;\n    }\n    this.on('close', cb);\n  }\n\n  // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n  if (!this.autoClose)\n    this.on('finish', this.destroy.bind(this));\n\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n// =============================================================================\n\nmodule.exports = {\n  flagsToString,\n  OPEN_MODE,\n  SFTP,\n  Stats,\n  STATUS_CODE,\n  stringToFlags,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
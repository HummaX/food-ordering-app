{"ast":null,"code":"'use strict';\n\nconst {\n  kMaxLength\n} = require('buffer');\nconst {\n  createInflate,\n  constants: {\n    DEFLATE,\n    INFLATE,\n    Z_DEFAULT_CHUNK,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_MEMLEVEL,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFAULT_WINDOWBITS,\n    Z_PARTIAL_FLUSH\n  }\n} = require('zlib');\nconst ZlibHandle = createInflate()._handle.constructor;\nfunction processCallback() {\n  throw new Error('Should not get here');\n}\nfunction zlibOnError(message, errno, code) {\n  const self = this._owner;\n  // There is no way to cleanly recover.\n  // Continuing only obscures problems.\n\n  const error = new Error(message);\n  error.errno = errno;\n  error.code = code;\n  self._err = error;\n}\nfunction _close(engine) {\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n  engine._handle.close();\n  engine._handle = null;\n}\nclass Zlib {\n  constructor(mode) {\n    const windowBits = Z_DEFAULT_WINDOWBITS;\n    const level = Z_DEFAULT_COMPRESSION;\n    const memLevel = Z_DEFAULT_MEMLEVEL;\n    const strategy = Z_DEFAULT_STRATEGY;\n    const dictionary = undefined;\n    this._err = undefined;\n    this._writeState = new Uint32Array(2);\n    this._chunkSize = Z_DEFAULT_CHUNK;\n    this._maxOutputLength = kMaxLength;\n    this._outBuffer = Buffer.allocUnsafe(this._chunkSize);\n    this._outOffset = 0;\n    this._handle = new ZlibHandle(mode);\n    this._handle._owner = this;\n    this._handle.onerror = zlibOnError;\n    this._handle.init(windowBits, level, memLevel, strategy, this._writeState, processCallback, dictionary);\n  }\n  writeSync(chunk, retChunks) {\n    const handle = this._handle;\n    if (!handle) throw new Error('Invalid Zlib instance');\n    let availInBefore = chunk.length;\n    let availOutBefore = this._chunkSize - this._outOffset;\n    let inOff = 0;\n    let availOutAfter;\n    let availInAfter;\n    let buffers;\n    let nread = 0;\n    const state = this._writeState;\n    let buffer = this._outBuffer;\n    let offset = this._outOffset;\n    const chunkSize = this._chunkSize;\n    while (true) {\n      handle.writeSync(Z_PARTIAL_FLUSH, chunk,\n      // in\n      inOff,\n      // in_off\n      availInBefore,\n      // in_len\n      buffer,\n      // out\n      offset,\n      // out_off\n      availOutBefore); // out_len\n      if (this._err) throw this._err;\n      availOutAfter = state[0];\n      availInAfter = state[1];\n      const inDelta = availInBefore - availInAfter;\n      const have = availOutBefore - availOutAfter;\n      if (have > 0) {\n        const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);\n        offset += have;\n        if (!buffers) buffers = out;else if (buffers.push === undefined) buffers = [buffers, out];else buffers.push(out);\n        nread += out.byteLength;\n        if (nread > this._maxOutputLength) {\n          _close(this);\n          throw new Error(`Output length exceeded maximum of ${this._maxOutputLength}`);\n        }\n      } else if (have !== 0) {\n        throw new Error('have should not go down');\n      }\n\n      // Exhausted the output buffer, or used all the input create a new one.\n      if (availOutAfter === 0 || offset >= chunkSize) {\n        availOutBefore = chunkSize;\n        offset = 0;\n        buffer = Buffer.allocUnsafe(chunkSize);\n      }\n      if (availOutAfter === 0) {\n        // Not actually done. Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += inDelta;\n        availInBefore = availInAfter;\n      } else {\n        break;\n      }\n    }\n    this._outBuffer = buffer;\n    this._outOffset = offset;\n    if (nread === 0) buffers = Buffer.alloc(0);\n    if (retChunks) {\n      buffers.totalLen = nread;\n      return buffers;\n    }\n    if (buffers.push === undefined) return buffers;\n    const output = Buffer.allocUnsafe(nread);\n    for (let i = 0, p = 0; i < buffers.length; ++i) {\n      const buf = buffers[i];\n      output.set(buf, p);\n      p += buf.length;\n    }\n    return output;\n  }\n}\nclass ZlibPacketWriter {\n  constructor(protocol) {\n    this.allocStart = 0;\n    this.allocStartKEX = 0;\n    this._protocol = protocol;\n    this._zlib = new Zlib(DEFLATE);\n  }\n  cleanup() {\n    if (this._zlib) _close(this._zlib);\n  }\n  alloc(payloadSize, force) {\n    return Buffer.allocUnsafe(payloadSize);\n  }\n  finalize(payload, force) {\n    if (this._protocol._kexinit === undefined || force) {\n      const output = this._zlib.writeSync(payload, true);\n      const packet = this._protocol._cipher.allocPacket(output.totalLen);\n      if (output.push === undefined) {\n        packet.set(output, 5);\n      } else {\n        for (let i = 0, p = 5; i < output.length; ++i) {\n          const chunk = output[i];\n          packet.set(chunk, p);\n          p += chunk.length;\n        }\n      }\n      return packet;\n    }\n    return payload;\n  }\n}\nclass PacketWriter {\n  constructor(protocol) {\n    this.allocStart = 5;\n    this.allocStartKEX = 5;\n    this._protocol = protocol;\n  }\n  cleanup() {}\n  alloc(payloadSize, force) {\n    if (this._protocol._kexinit === undefined || force) return this._protocol._cipher.allocPacket(payloadSize);\n    return Buffer.allocUnsafe(payloadSize);\n  }\n  finalize(packet, force) {\n    return packet;\n  }\n}\nclass ZlibPacketReader {\n  constructor() {\n    this._zlib = new Zlib(INFLATE);\n  }\n  cleanup() {\n    if (this._zlib) _close(this._zlib);\n  }\n  read(data) {\n    return this._zlib.writeSync(data, false);\n  }\n}\nclass PacketReader {\n  cleanup() {}\n  read(data) {\n    return data;\n  }\n}\nmodule.exports = {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n};","map":{"version":3,"names":["kMaxLength","require","createInflate","constants","DEFLATE","INFLATE","Z_DEFAULT_CHUNK","Z_DEFAULT_COMPRESSION","Z_DEFAULT_MEMLEVEL","Z_DEFAULT_STRATEGY","Z_DEFAULT_WINDOWBITS","Z_PARTIAL_FLUSH","ZlibHandle","_handle","constructor","processCallback","Error","zlibOnError","message","errno","code","self","_owner","error","_err","_close","engine","close","Zlib","mode","windowBits","level","memLevel","strategy","dictionary","undefined","_writeState","Uint32Array","_chunkSize","_maxOutputLength","_outBuffer","Buffer","allocUnsafe","_outOffset","onerror","init","writeSync","chunk","retChunks","handle","availInBefore","length","availOutBefore","inOff","availOutAfter","availInAfter","buffers","nread","state","buffer","offset","chunkSize","inDelta","have","out","slice","push","byteLength","alloc","totalLen","output","i","p","buf","set","ZlibPacketWriter","protocol","allocStart","allocStartKEX","_protocol","_zlib","cleanup","payloadSize","force","finalize","payload","_kexinit","packet","_cipher","allocPacket","PacketWriter","ZlibPacketReader","read","data","PacketReader","module","exports"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/protocol/zlib.js"],"sourcesContent":["'use strict';\n\nconst { kMaxLength } = require('buffer');\nconst {\n  createInflate,\n  constants: {\n    DEFLATE,\n    INFLATE,\n    Z_DEFAULT_CHUNK,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_MEMLEVEL,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFAULT_WINDOWBITS,\n    Z_PARTIAL_FLUSH,\n  }\n} = require('zlib');\nconst ZlibHandle = createInflate()._handle.constructor;\n\nfunction processCallback() {\n  throw new Error('Should not get here');\n}\n\nfunction zlibOnError(message, errno, code) {\n  const self = this._owner;\n  // There is no way to cleanly recover.\n  // Continuing only obscures problems.\n\n  const error = new Error(message);\n  error.errno = errno;\n  error.code = code;\n  self._err = error;\n}\n\nfunction _close(engine) {\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle)\n    return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nclass Zlib {\n  constructor(mode) {\n    const windowBits = Z_DEFAULT_WINDOWBITS;\n    const level = Z_DEFAULT_COMPRESSION;\n    const memLevel = Z_DEFAULT_MEMLEVEL;\n    const strategy = Z_DEFAULT_STRATEGY;\n    const dictionary = undefined;\n\n    this._err = undefined;\n    this._writeState = new Uint32Array(2);\n    this._chunkSize = Z_DEFAULT_CHUNK;\n    this._maxOutputLength = kMaxLength;\n    this._outBuffer = Buffer.allocUnsafe(this._chunkSize);\n    this._outOffset = 0;\n\n    this._handle = new ZlibHandle(mode);\n    this._handle._owner = this;\n    this._handle.onerror = zlibOnError;\n    this._handle.init(windowBits,\n                      level,\n                      memLevel,\n                      strategy,\n                      this._writeState,\n                      processCallback,\n                      dictionary);\n  }\n\n  writeSync(chunk, retChunks) {\n    const handle = this._handle;\n    if (!handle)\n      throw new Error('Invalid Zlib instance');\n\n    let availInBefore = chunk.length;\n    let availOutBefore = this._chunkSize - this._outOffset;\n    let inOff = 0;\n    let availOutAfter;\n    let availInAfter;\n\n    let buffers;\n    let nread = 0;\n    const state = this._writeState;\n    let buffer = this._outBuffer;\n    let offset = this._outOffset;\n    const chunkSize = this._chunkSize;\n\n    while (true) {\n      handle.writeSync(Z_PARTIAL_FLUSH,\n                       chunk, // in\n                       inOff, // in_off\n                       availInBefore, // in_len\n                       buffer, // out\n                       offset, // out_off\n                       availOutBefore); // out_len\n      if (this._err)\n        throw this._err;\n\n      availOutAfter = state[0];\n      availInAfter = state[1];\n\n      const inDelta = availInBefore - availInAfter;\n      const have = availOutBefore - availOutAfter;\n\n      if (have > 0) {\n        const out = (offset === 0 && have === buffer.length\n                     ? buffer\n                     : buffer.slice(offset, offset + have));\n        offset += have;\n        if (!buffers)\n          buffers = out;\n        else if (buffers.push === undefined)\n          buffers = [buffers, out];\n        else\n          buffers.push(out);\n        nread += out.byteLength;\n\n        if (nread > this._maxOutputLength) {\n          _close(this);\n          throw new Error(\n            `Output length exceeded maximum of ${this._maxOutputLength}`\n          );\n        }\n      } else if (have !== 0) {\n        throw new Error('have should not go down');\n      }\n\n      // Exhausted the output buffer, or used all the input create a new one.\n      if (availOutAfter === 0 || offset >= chunkSize) {\n        availOutBefore = chunkSize;\n        offset = 0;\n        buffer = Buffer.allocUnsafe(chunkSize);\n      }\n\n      if (availOutAfter === 0) {\n        // Not actually done. Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += inDelta;\n        availInBefore = availInAfter;\n      } else {\n        break;\n      }\n    }\n\n    this._outBuffer = buffer;\n    this._outOffset = offset;\n\n    if (nread === 0)\n      buffers = Buffer.alloc(0);\n\n    if (retChunks) {\n      buffers.totalLen = nread;\n      return buffers;\n    }\n\n    if (buffers.push === undefined)\n      return buffers;\n\n    const output = Buffer.allocUnsafe(nread);\n    for (let i = 0, p = 0; i < buffers.length; ++i) {\n      const buf = buffers[i];\n      output.set(buf, p);\n      p += buf.length;\n    }\n    return output;\n  }\n}\n\nclass ZlibPacketWriter {\n  constructor(protocol) {\n    this.allocStart = 0;\n    this.allocStartKEX = 0;\n    this._protocol = protocol;\n    this._zlib = new Zlib(DEFLATE);\n  }\n\n  cleanup() {\n    if (this._zlib)\n      _close(this._zlib);\n  }\n\n  alloc(payloadSize, force) {\n    return Buffer.allocUnsafe(payloadSize);\n  }\n\n  finalize(payload, force) {\n    if (this._protocol._kexinit === undefined || force) {\n      const output = this._zlib.writeSync(payload, true);\n      const packet = this._protocol._cipher.allocPacket(output.totalLen);\n      if (output.push === undefined) {\n        packet.set(output, 5);\n      } else {\n        for (let i = 0, p = 5; i < output.length; ++i) {\n          const chunk = output[i];\n          packet.set(chunk, p);\n          p += chunk.length;\n        }\n      }\n      return packet;\n    }\n    return payload;\n  }\n}\n\nclass PacketWriter {\n  constructor(protocol) {\n    this.allocStart = 5;\n    this.allocStartKEX = 5;\n    this._protocol = protocol;\n  }\n\n  cleanup() {}\n\n  alloc(payloadSize, force) {\n    if (this._protocol._kexinit === undefined || force)\n      return this._protocol._cipher.allocPacket(payloadSize);\n    return Buffer.allocUnsafe(payloadSize);\n  }\n\n  finalize(packet, force) {\n    return packet;\n  }\n}\n\nclass ZlibPacketReader {\n  constructor() {\n    this._zlib = new Zlib(INFLATE);\n  }\n\n  cleanup() {\n    if (this._zlib)\n      _close(this._zlib);\n  }\n\n  read(data) {\n    return this._zlib.writeSync(data, false);\n  }\n}\n\nclass PacketReader {\n  cleanup() {}\n\n  read(data) {\n    return data;\n  }\n}\n\nmodule.exports = {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
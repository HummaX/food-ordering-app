{"ast":null,"code":"'use strict';\n\nconst Ber = require('asn1').Ber;\nlet DISCONNECT_REASON;\nconst FastBuffer = Buffer[Symbol.species];\nconst TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;\nfunction readUInt32BE(buf, offset) {\n  return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];\n}\nfunction bufferCopy(src, dest, srcStart, srcEnd, destStart) {\n  if (!destStart) destStart = 0;\n  if (srcEnd > src.length) srcEnd = src.length;\n  let nb = srcEnd - srcStart;\n  const destLeft = dest.length - destStart;\n  if (nb > destLeft) nb = destLeft;\n  dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb), destStart);\n  return nb;\n}\nfunction bufferSlice(buf, start, end) {\n  if (end === undefined) end = buf.length;\n  return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);\n}\nfunction makeBufferParser() {\n  let pos = 0;\n  let buffer;\n  const self = {\n    init: (buf, start) => {\n      buffer = buf;\n      pos = typeof start === 'number' ? start : 0;\n    },\n    pos: () => pos,\n    length: () => buffer ? buffer.length : 0,\n    avail: () => buffer && pos < buffer.length ? buffer.length - pos : 0,\n    clear: () => {\n      buffer = undefined;\n    },\n    readUInt32BE: () => {\n      if (!buffer || pos + 3 >= buffer.length) return;\n      return buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];\n    },\n    readUInt64BE: behavior => {\n      if (!buffer || pos + 7 >= buffer.length) return;\n      switch (behavior) {\n        case 'always':\n          return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        case 'maybe':\n          if (buffer[pos] > 0x1F) return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        // FALLTHROUGH\n        default:\n          return buffer[pos++] * 72057594037927940 + buffer[pos++] * 281474976710656 + buffer[pos++] * 1099511627776 + buffer[pos++] * 4294967296 + buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];\n      }\n    },\n    skip: n => {\n      if (buffer && n > 0) pos += n;\n    },\n    skipString: () => {\n      const len = self.readUInt32BE();\n      if (len === undefined) return;\n      pos += len;\n      return pos <= buffer.length ? len : undefined;\n    },\n    readByte: () => {\n      if (buffer && pos < buffer.length) return buffer[pos++];\n    },\n    readBool: () => {\n      if (buffer && pos < buffer.length) return !!buffer[pos++];\n    },\n    readList: () => {\n      const list = self.readString(true);\n      if (list === undefined) return;\n      return list ? list.split(',') : [];\n    },\n    readString: (dest, maxLen) => {\n      if (typeof dest === 'number') {\n        maxLen = dest;\n        dest = undefined;\n      }\n      const len = self.readUInt32BE();\n      if (len === undefined) return;\n      if (buffer.length - pos < len || typeof maxLen === 'number' && len > maxLen) {\n        return;\n      }\n      if (dest) {\n        if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, pos, pos += len);\n        return buffer.utf8Slice(pos, pos += len);\n      }\n      return bufferSlice(buffer, pos, pos += len);\n    },\n    readRaw: len => {\n      if (!buffer) return;\n      if (typeof len !== 'number') return bufferSlice(buffer, pos, pos += buffer.length - pos);\n      if (buffer.length - pos >= len) return bufferSlice(buffer, pos, pos += len);\n    }\n  };\n  return self;\n}\nfunction makeError(msg, level, fatal) {\n  const err = new Error(msg);\n  if (typeof level === 'boolean') {\n    fatal = level;\n    err.level = 'protocol';\n  } else {\n    err.level = level || 'protocol';\n  }\n  err.fatal = !!fatal;\n  return err;\n}\nfunction writeUInt32BE(buf, value, offset) {\n  buf[offset++] = value >>> 24;\n  buf[offset++] = value >>> 16;\n  buf[offset++] = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\nconst utilBufferParser = makeBufferParser();\nmodule.exports = {\n  bufferCopy,\n  bufferSlice,\n  FastBuffer,\n  bufferFill: (buf, value, start, end) => {\n    return TypedArrayFill.call(buf, value, start, end);\n  },\n  makeError,\n  doFatalError: (protocol, msg, level, reason) => {\n    let err;\n    if (DISCONNECT_REASON === undefined) ({\n      DISCONNECT_REASON\n    } = require('./constants.js'));\n    if (msg instanceof Error) {\n      // doFatalError(protocol, err[, reason])\n      err = msg;\n      if (typeof level !== 'number') reason = DISCONNECT_REASON.PROTOCOL_ERROR;else reason = level;\n    } else {\n      // doFatalError(protocol, msg[, level[, reason]])\n      err = makeError(msg, level, true);\n    }\n    if (typeof reason !== 'number') reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    protocol.disconnect(reason);\n    protocol._destruct();\n    protocol._onError(err);\n    return Infinity;\n  },\n  readUInt32BE,\n  writeUInt32BE,\n  writeUInt32LE: (buf, value, offset) => {\n    buf[offset++] = value;\n    buf[offset++] = value >>> 8;\n    buf[offset++] = value >>> 16;\n    buf[offset++] = value >>> 24;\n    return offset;\n  },\n  makeBufferParser,\n  bufferParser: makeBufferParser(),\n  readString: (buffer, start, dest, maxLen) => {\n    if (typeof dest === 'number') {\n      maxLen = dest;\n      dest = undefined;\n    }\n    if (start === undefined) start = 0;\n    const left = buffer.length - start;\n    if (start < 0 || start >= buffer.length || left < 4) return;\n    const len = readUInt32BE(buffer, start);\n    if (left < 4 + len || typeof maxLen === 'number' && len > maxLen) return;\n    start += 4;\n    const end = start + len;\n    buffer._pos = end;\n    if (dest) {\n      if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, start, end);\n      return buffer.utf8Slice(start, end);\n    }\n    return bufferSlice(buffer, start, end);\n  },\n  sigSSHToASN1: (sig, type) => {\n    switch (type) {\n      case 'ssh-dss':\n        {\n          if (sig.length > 40) return sig;\n          // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n          const asnWriter = new Ber.Writer();\n          asnWriter.startSequence();\n          let r = sig.slice(0, 20);\n          let s = sig.slice(20);\n          if (r[0] & 0x80) {\n            const rNew = Buffer.allocUnsafe(21);\n            rNew[0] = 0x00;\n            r.copy(rNew, 1);\n            r = rNew;\n          } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n            r = r.slice(1);\n          }\n          if (s[0] & 0x80) {\n            const sNew = Buffer.allocUnsafe(21);\n            sNew[0] = 0x00;\n            s.copy(sNew, 1);\n            s = sNew;\n          } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n            s = s.slice(1);\n          }\n          asnWriter.writeBuffer(r, Ber.Integer);\n          asnWriter.writeBuffer(s, Ber.Integer);\n          asnWriter.endSequence();\n          return asnWriter.buffer;\n        }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521':\n        {\n          utilBufferParser.init(sig, 0);\n          const r = utilBufferParser.readString();\n          const s = utilBufferParser.readString();\n          utilBufferParser.clear();\n          if (r === undefined || s === undefined) return;\n          const asnWriter = new Ber.Writer();\n          asnWriter.startSequence();\n          asnWriter.writeBuffer(r, Ber.Integer);\n          asnWriter.writeBuffer(s, Ber.Integer);\n          asnWriter.endSequence();\n          return asnWriter.buffer;\n        }\n      default:\n        return sig;\n    }\n  },\n  convertSignature: (signature, keyType) => {\n    switch (keyType) {\n      case 'ssh-dss':\n        {\n          if (signature.length <= 40) return signature;\n          // This is a quick and dirty way to get from BER encoded r and s that\n          // OpenSSL gives us, to just the bare values back to back (40 bytes\n          // total) like OpenSSH (and possibly others) are expecting\n          const asnReader = new Ber.Reader(signature);\n          asnReader.readSequence();\n          let r = asnReader.readString(Ber.Integer, true);\n          let s = asnReader.readString(Ber.Integer, true);\n          let rOffset = 0;\n          let sOffset = 0;\n          if (r.length < 20) {\n            const rNew = Buffer.allocUnsafe(20);\n            rNew.set(r, 1);\n            r = rNew;\n            r[0] = 0;\n          }\n          if (s.length < 20) {\n            const sNew = Buffer.allocUnsafe(20);\n            sNew.set(s, 1);\n            s = sNew;\n            s[0] = 0;\n          }\n          if (r.length > 20 && r[0] === 0) rOffset = 1;\n          if (s.length > 20 && s[0] === 0) sOffset = 1;\n          const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));\n          bufferCopy(r, newSig, rOffset, r.length, 0);\n          bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);\n          return newSig;\n        }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521':\n        {\n          if (signature[0] === 0) return signature;\n          // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n          const asnReader = new Ber.Reader(signature);\n          asnReader.readSequence();\n          const r = asnReader.readString(Ber.Integer, true);\n          const s = asnReader.readString(Ber.Integer, true);\n          if (r === null || s === null) return;\n          const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n          writeUInt32BE(newSig, r.length, 0);\n          newSig.set(r, 4);\n          writeUInt32BE(newSig, s.length, 4 + r.length);\n          newSig.set(s, 4 + 4 + r.length);\n          return newSig;\n        }\n    }\n    return signature;\n  },\n  sendPacket: (proto, packet, bypass) => {\n    if (!bypass && proto._kexinit !== undefined) {\n      // We're currently in the middle of a handshake\n\n      if (proto._queue === undefined) proto._queue = [];\n      proto._queue.push(packet);\n      proto._debug && proto._debug('Outbound: ... packet queued');\n      return false;\n    }\n    proto._cipher.encrypt(packet);\n    return true;\n  }\n};","map":{"version":3,"names":["Ber","require","DISCONNECT_REASON","FastBuffer","Buffer","Symbol","species","TypedArrayFill","Object","getPrototypeOf","Uint8Array","prototype","fill","readUInt32BE","buf","offset","bufferCopy","src","dest","srcStart","srcEnd","destStart","length","nb","destLeft","set","buffer","byteOffset","bufferSlice","start","end","undefined","makeBufferParser","pos","self","init","avail","clear","readUInt64BE","behavior","BigInt","hexSlice","skip","n","skipString","len","readByte","readBool","readList","list","readString","split","maxLen","isBuffer","utf8Slice","readRaw","makeError","msg","level","fatal","err","Error","writeUInt32BE","value","utilBufferParser","module","exports","bufferFill","call","doFatalError","protocol","reason","PROTOCOL_ERROR","disconnect","_destruct","_onError","Infinity","writeUInt32LE","bufferParser","left","_pos","sigSSHToASN1","sig","type","asnWriter","Writer","startSequence","r","slice","s","rNew","allocUnsafe","copy","sNew","writeBuffer","Integer","endSequence","convertSignature","signature","keyType","asnReader","Reader","readSequence","rOffset","sOffset","newSig","sendPacket","proto","packet","bypass","_kexinit","_queue","push","_debug","_cipher","encrypt"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/protocol/utils.js"],"sourcesContent":["'use strict';\n\nconst Ber = require('asn1').Ber;\n\nlet DISCONNECT_REASON;\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;\n\nfunction readUInt32BE(buf, offset) {\n  return (buf[offset++] * 16777216)\n         + (buf[offset++] * 65536)\n         + (buf[offset++] * 256)\n         + buf[offset];\n}\n\nfunction bufferCopy(src, dest, srcStart, srcEnd, destStart) {\n  if (!destStart)\n    destStart = 0;\n  if (srcEnd > src.length)\n    srcEnd = src.length;\n  let nb = srcEnd - srcStart;\n  const destLeft = (dest.length - destStart);\n  if (nb > destLeft)\n    nb = destLeft;\n  dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),\n           destStart);\n  return nb;\n}\n\nfunction bufferSlice(buf, start, end) {\n  if (end === undefined)\n    end = buf.length;\n  return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);\n}\n\nfunction makeBufferParser() {\n  let pos = 0;\n  let buffer;\n\n  const self = {\n    init: (buf, start) => {\n      buffer = buf;\n      pos = (typeof start === 'number' ? start : 0);\n    },\n    pos: () => pos,\n    length: () => (buffer ? buffer.length : 0),\n    avail: () => (buffer && pos < buffer.length ? buffer.length - pos : 0),\n    clear: () => {\n      buffer = undefined;\n    },\n    readUInt32BE: () => {\n      if (!buffer || pos + 3 >= buffer.length)\n        return;\n      return (buffer[pos++] * 16777216)\n             + (buffer[pos++] * 65536)\n             + (buffer[pos++] * 256)\n             + buffer[pos++];\n    },\n    readUInt64BE: (behavior) => {\n      if (!buffer || pos + 7 >= buffer.length)\n        return;\n      switch (behavior) {\n        case 'always':\n          return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        case 'maybe':\n          if (buffer[pos] > 0x1F)\n            return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n          // FALLTHROUGH\n        default:\n          return (buffer[pos++] * 72057594037927940)\n                 + (buffer[pos++] * 281474976710656)\n                 + (buffer[pos++] * 1099511627776)\n                 + (buffer[pos++] * 4294967296)\n                 + (buffer[pos++] * 16777216)\n                 + (buffer[pos++] * 65536)\n                 + (buffer[pos++] * 256)\n                 + buffer[pos++];\n      }\n    },\n    skip: (n) => {\n      if (buffer && n > 0)\n        pos += n;\n    },\n    skipString: () => {\n      const len = self.readUInt32BE();\n      if (len === undefined)\n        return;\n      pos += len;\n      return (pos <= buffer.length ? len : undefined);\n    },\n    readByte: () => {\n      if (buffer && pos < buffer.length)\n        return buffer[pos++];\n    },\n    readBool: () => {\n      if (buffer && pos < buffer.length)\n        return !!buffer[pos++];\n    },\n    readList: () => {\n      const list = self.readString(true);\n      if (list === undefined)\n        return;\n      return (list ? list.split(',') : []);\n    },\n    readString: (dest, maxLen) => {\n      if (typeof dest === 'number') {\n        maxLen = dest;\n        dest = undefined;\n      }\n\n      const len = self.readUInt32BE();\n      if (len === undefined)\n        return;\n\n      if ((buffer.length - pos) < len\n          || (typeof maxLen === 'number' && len > maxLen)) {\n        return;\n      }\n\n      if (dest) {\n        if (Buffer.isBuffer(dest))\n          return bufferCopy(buffer, dest, pos, pos += len);\n        return buffer.utf8Slice(pos, pos += len);\n      }\n      return bufferSlice(buffer, pos, pos += len);\n    },\n    readRaw: (len) => {\n      if (!buffer)\n        return;\n      if (typeof len !== 'number')\n        return bufferSlice(buffer, pos, pos += (buffer.length - pos));\n      if ((buffer.length - pos) >= len)\n        return bufferSlice(buffer, pos, pos += len);\n    },\n  };\n\n  return self;\n}\n\nfunction makeError(msg, level, fatal) {\n  const err = new Error(msg);\n  if (typeof level === 'boolean') {\n    fatal = level;\n    err.level = 'protocol';\n  } else {\n    err.level = level || 'protocol';\n  }\n  err.fatal = !!fatal;\n  return err;\n}\n\nfunction writeUInt32BE(buf, value, offset) {\n  buf[offset++] = (value >>> 24);\n  buf[offset++] = (value >>> 16);\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nconst utilBufferParser = makeBufferParser();\n\nmodule.exports = {\n  bufferCopy,\n  bufferSlice,\n  FastBuffer,\n  bufferFill: (buf, value, start, end) => {\n    return TypedArrayFill.call(buf, value, start, end);\n  },\n  makeError,\n  doFatalError: (protocol, msg, level, reason) => {\n    let err;\n    if (DISCONNECT_REASON === undefined)\n      ({ DISCONNECT_REASON } = require('./constants.js'));\n    if (msg instanceof Error) {\n      // doFatalError(protocol, err[, reason])\n      err = msg;\n      if (typeof level !== 'number')\n        reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n      else\n        reason = level;\n    } else {\n      // doFatalError(protocol, msg[, level[, reason]])\n      err = makeError(msg, level, true);\n    }\n    if (typeof reason !== 'number')\n      reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    protocol.disconnect(reason);\n    protocol._destruct();\n    protocol._onError(err);\n    return Infinity;\n  },\n  readUInt32BE,\n  writeUInt32BE,\n  writeUInt32LE: (buf, value, offset) => {\n    buf[offset++] = value;\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 24);\n    return offset;\n  },\n  makeBufferParser,\n  bufferParser: makeBufferParser(),\n  readString: (buffer, start, dest, maxLen) => {\n    if (typeof dest === 'number') {\n      maxLen = dest;\n      dest = undefined;\n    }\n\n    if (start === undefined)\n      start = 0;\n\n    const left = (buffer.length - start);\n    if (start < 0 || start >= buffer.length || left < 4)\n      return;\n\n    const len = readUInt32BE(buffer, start);\n    if (left < (4 + len) || (typeof maxLen === 'number' && len > maxLen))\n      return;\n\n    start += 4;\n    const end = start + len;\n    buffer._pos = end;\n\n    if (dest) {\n      if (Buffer.isBuffer(dest))\n        return bufferCopy(buffer, dest, start, end);\n      return buffer.utf8Slice(start, end);\n    }\n    return bufferSlice(buffer, start, end);\n  },\n  sigSSHToASN1: (sig, type) => {\n    switch (type) {\n      case 'ssh-dss': {\n        if (sig.length > 40)\n          return sig;\n        // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n        let r = sig.slice(0, 20);\n        let s = sig.slice(20);\n        if (r[0] & 0x80) {\n          const rNew = Buffer.allocUnsafe(21);\n          rNew[0] = 0x00;\n          r.copy(rNew, 1);\n          r = rNew;\n        } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n          r = r.slice(1);\n        }\n        if (s[0] & 0x80) {\n          const sNew = Buffer.allocUnsafe(21);\n          sNew[0] = 0x00;\n          s.copy(sNew, 1);\n          s = sNew;\n        } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n          s = s.slice(1);\n        }\n        asnWriter.writeBuffer(r, Ber.Integer);\n        asnWriter.writeBuffer(s, Ber.Integer);\n        asnWriter.endSequence();\n        return asnWriter.buffer;\n      }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521': {\n        utilBufferParser.init(sig, 0);\n        const r = utilBufferParser.readString();\n        const s = utilBufferParser.readString();\n        utilBufferParser.clear();\n        if (r === undefined || s === undefined)\n          return;\n\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n        asnWriter.writeBuffer(r, Ber.Integer);\n        asnWriter.writeBuffer(s, Ber.Integer);\n        asnWriter.endSequence();\n        return asnWriter.buffer;\n      }\n      default:\n        return sig;\n    }\n  },\n  convertSignature: (signature, keyType) => {\n    switch (keyType) {\n      case 'ssh-dss': {\n        if (signature.length <= 40)\n          return signature;\n        // This is a quick and dirty way to get from BER encoded r and s that\n        // OpenSSL gives us, to just the bare values back to back (40 bytes\n        // total) like OpenSSH (and possibly others) are expecting\n        const asnReader = new Ber.Reader(signature);\n        asnReader.readSequence();\n        let r = asnReader.readString(Ber.Integer, true);\n        let s = asnReader.readString(Ber.Integer, true);\n        let rOffset = 0;\n        let sOffset = 0;\n        if (r.length < 20) {\n          const rNew = Buffer.allocUnsafe(20);\n          rNew.set(r, 1);\n          r = rNew;\n          r[0] = 0;\n        }\n        if (s.length < 20) {\n          const sNew = Buffer.allocUnsafe(20);\n          sNew.set(s, 1);\n          s = sNew;\n          s[0] = 0;\n        }\n        if (r.length > 20 && r[0] === 0)\n          rOffset = 1;\n        if (s.length > 20 && s[0] === 0)\n          sOffset = 1;\n        const newSig =\n          Buffer.allocUnsafe((r.length - rOffset) + (s.length - sOffset));\n        bufferCopy(r, newSig, rOffset, r.length, 0);\n        bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);\n        return newSig;\n      }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521': {\n        if (signature[0] === 0)\n          return signature;\n        // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n        const asnReader = new Ber.Reader(signature);\n        asnReader.readSequence();\n        const r = asnReader.readString(Ber.Integer, true);\n        const s = asnReader.readString(Ber.Integer, true);\n        if (r === null || s === null)\n          return;\n        const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n        writeUInt32BE(newSig, r.length, 0);\n        newSig.set(r, 4);\n        writeUInt32BE(newSig, s.length, 4 + r.length);\n        newSig.set(s, 4 + 4 + r.length);\n        return newSig;\n      }\n    }\n\n    return signature;\n  },\n  sendPacket: (proto, packet, bypass) => {\n    if (!bypass && proto._kexinit !== undefined) {\n      // We're currently in the middle of a handshake\n\n      if (proto._queue === undefined)\n        proto._queue = [];\n      proto._queue.push(packet);\n      proto._debug && proto._debug('Outbound: ... packet queued');\n      return false;\n    }\n    proto._cipher.encrypt(packet);\n    return true;\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
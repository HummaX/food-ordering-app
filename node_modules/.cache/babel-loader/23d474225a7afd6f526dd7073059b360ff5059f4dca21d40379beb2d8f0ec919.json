{"ast":null,"code":"/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n\n'use strict';\n\nconst {\n  inspect\n} = require('util');\nconst {\n  bindingAvailable,\n  NullCipher,\n  NullDecipher\n} = require('./crypto.js');\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE\n} = require('./constants.js');\nconst {\n  DEFAULT_KEXINIT,\n  KexInit,\n  kexinit,\n  onKEXPayload\n} = require('./kex.js');\nconst {\n  parseKey\n} = require('./keyParser.js');\nconst MESSAGE_HANDLERS = require('./handlers.js');\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\nconst MODULE_VER = require('../../package.json').version;\nconst VALID_DISCONNECT_REASONS = new Map(Object.values(DISCONNECT_REASON).map(n => [n, 1]));\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([MESSAGE.GLOBAL_REQUEST,\n// \"keepalive@openssh.com\"\n0, 0, 0, 21, 107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115, 115, 104, 46, 99, 111, 109,\n// Request a reply\n1]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);\nfunction noop() {}\n\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\nclass Protocol {\n  constructor(config) {\n    var _this = this;\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function') throw new Error('Missing onWrite function');\n    this._onWrite = data => {\n      onWrite(data);\n    };\n    const onError = config.onError;\n    if (typeof onError !== 'function') throw new Error('Missing onError function');\n    this._onError = err => {\n      onError(err);\n    };\n    const debug = config.debug;\n    this._debug = typeof debug === 'function' ? msg => {\n      debug(msg);\n    } : undefined;\n    const onHeader = config.onHeader;\n    this._onHeader = typeof onHeader === 'function' ? function () {\n      onHeader(...arguments);\n    } : noop;\n    const onPacket = config.onPacket;\n    this._onPacket = typeof onPacket === 'function' ? () => {\n      onPacket();\n    } : noop;\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function') onHandshakeComplete = noop;\n    this._onHandshakeComplete = function () {\n      _this._debug && _this._debug('Handshake completed');\n\n      // Process packets queued during a rekey where necessary\n      const oldQueue = _this._queue;\n      if (oldQueue) {\n        _this._queue = undefined;\n        _this._debug && _this._debug(`Draining outbound queue (${oldQueue.length}) ...`);\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i];\n          // data === payload only\n\n          // XXX: hacky\n          let finalized = _this._packetRW.write.finalize(data);\n          if (finalized === data) {\n            const packet = _this._cipher.allocPacket(data.length);\n            packet.set(data, 5);\n            finalized = packet;\n          }\n          sendPacket(_this, finalized);\n        }\n        _this._debug && _this._debug('... finished draining outbound queue');\n      }\n      onHandshakeComplete(...arguments);\n    };\n    this._queue = undefined;\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null) this._handlers = messageHandlers;else this._handlers = {};\n    this._onPayload = onPayload.bind(this);\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null) throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys;\n\n      // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = config.greeting.slice(-2) === '\\r\\n' ? config.greeting : `${config.greeting}\\r\\n`;\n      }\n\n      // Banner shown after the handshake completes, but before user\n      // authentication begins\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = config.banner.slice(-2) === '\\r\\n' ? config.banner : `${config.banner}\\r\\n`;\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null) offer = DEFAULT_KEXINIT;else if (offer.constructor !== KexInit) offer = new KexInit(offer);\n    this._kex = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this)\n    };\n    this._hostVerifier = !this._server && typeof config.hostVerifier === 'function' ? config.hostVerifier : undefined;\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n    this._compatFlags = 0;\n    if (this._debug) {\n      if (bindingAvailable) this._debug('Custom crypto binding available');else this._debug('Custom crypto binding not available');\n    }\n    this._debug && this._debug(`Local ident: ${inspect(this._identRaw.toString())}`);\n    this.start = () => {\n      this.start = undefined;\n      if (greeting) this._onWrite(greeting);\n      this._onWrite(sentIdent);\n    };\n  }\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n    this._packetRW.write.cleanup();\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0) reason = 'fatal error';\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._destruct = undefined;\n  }\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n  parse(chunk, i, len) {\n    while (i < len) i = this._parse(chunk, i, len);\n  }\n\n  // Protocol message API\n\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4;\n    // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n    let p = this._packetRW.write.allocStartKEX;\n    const packet = this._packetRW.write.alloc(pktLen, true);\n    const end = p + pktLen;\n    if (!VALID_DISCONNECT_REASONS.has(reason)) reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n  ping() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n    packet.set(PING_PAYLOAD, p);\n    this._debug && this._debug('Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelSuccess(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelFailure(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelEOF(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_EOF;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelClose(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, amount, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n    packet[p] = MESSAGE.CHANNEL_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, type, p += 4);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, local, p += 4);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string') desc = '';\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, reason, p += 4);\n    writeUInt32BE(packet, descLen, p += 4);\n    p += 4;\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  service(name) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-userauth' service-specific\n  // -------------------------------\n  authPassword(username, password, newPassword) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0));\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n    packet[p += 8] = newPassword ? 1 : 0;\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password)) bufferCopy(password, packet, 0, passLen, p += 4);else packet.utf8Write(password, p += 4, passLen);\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword)) bufferCopy(newPassword, packet, 0, newPassLen, p += 4);else packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (changed password)');\n    } else {\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (password)');\n    }\n    this._authsQueue.push('password');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPK(username, pubKey, cbSign) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n    packet[p += 9] = cbSign ? 1 : 0;\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyType, p += 4, algoLen);\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey -- check)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n    cbSign(packet, signature => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen);\n\n      // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n      packet[p += 9] = 1;\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n      this._authsQueue.push('publickey');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authHostbased(username, pubKey, hostname, userlocal, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen);\n    let p = 0;\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyType, p += 4, algoLen);\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n    cbSign(data, signature => {\n      signature = convertSignature(signature, keyType);\n      if (!signature) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      const reqDataLen = data.length - sesLen - 4;\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(reqDataLen + 4 + 4 + algoLen + 4 + sigLen);\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n      this._authsQueue.push('hostbased');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (hostbased)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authKeyboard(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4);\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n    writeUInt32BE(packet, 0, p += 20);\n    writeUInt32BE(packet, 0, p += 4);\n    this._authsQueue.push('keyboard-interactive');\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authNone(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n    this._authsQueue.push('none');\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoRes(responses) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let responsesTotalLen = 0;\n    let responseLens;\n    if (responses) {\n      responseLens = new Array(responses.length);\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n    packet[p += 13] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n    packet[p += 20] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + socketPathLen);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n    packet[p += 31] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + socketPathLen);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n    packet[p += 38] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST ' + '(cancel-streamlocal-forward@openssh.com)');\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n    writeUInt32BE(packet, chan, p += 12);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n    writeUInt32BE(packet, chan, p += 30);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    // zero-fill reserved fields (string and uint32)\n    bufferFill(packet, 0, p += pathLen, p + 8);\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, direct-streamlocal@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_noMoreSessions(wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n    packet[p += 28] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  session(chan, initWindow, maxPacket) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n    writeUInt32BE(packet, chan, p += 7);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n    packet[p += 13] = 0;\n    writeUInt32BE(packet, cols, ++p);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    if (!term || !term.length) term = 'vt100';\n    if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === 'object' && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n    if (!modes || !modes.length) modes = NO_TERMINAL_MODES_BUFFER;\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n    writeUInt32BE(packet, cols, p += termLen);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i) packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  shell(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n    packet[p += 5] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exec(chan, cmd, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n    packet[p += 4] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf) packet.set(cmd, p += 4);else packet.utf8Write(cmd, p += 4, cmdLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  signal(chan, signal) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const origSignal = signal;\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n    packet[p += 6] = 0;\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  env(chan, key, val, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = isBuf ? val.length : Buffer.byteLength(val);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n    packet[p += 3] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf) packet.set(val, p += 4);else packet.utf8Write(val, p += 4, valLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    packet[++p] = cfg.single ? 1 : 0;\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto) packet.set(protocol, p += 4);else packet.utf8Write(protocol, p += 4, protoLen);\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie) packet.set(cookie, p += 4);else packet.latin1Write(cookie, p += 4, cookieLen);\n    writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  subsystem(chan, name, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n    packet[p += 9] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_agentForward(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n    packet[p += 26] = wantReply === undefined || wantReply === true ? 1 : 0;\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_REQUEST ' + `(r:${chan}, auth-agent-req@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_hostKeysProve(keys) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let keysTotal = 0;\n    const publicKeys = [];\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)');\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  serviceAccept(svcName) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  }\n  // 'ssh-connection' service-specific\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n    writeUInt32BE(packet, chan, p += 15);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n    writeUInt32BE(packet, chan, p += 3);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n    writeUInt32BE(packet, chan, p += 22);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n    writeUInt32BE(packet, chan, p += 33);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n    writeUInt32BE(packet, 0, p += pathLen);\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, forwarded-streamlocal@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitStatus(chan, status) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, status, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n\n    const origSignal = name;\n    if (typeof origSignal !== 'string' || !origSignal) throw new Error(`Invalid signal: ${origSignal}`);\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = msg ? Buffer.byteLength(msg) : 0;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n    packet[p += nameLen] = coreDumped ? 1 : 0;\n    writeUInt32BE(packet, msgLen, ++p);\n    p += 4;\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n    writeUInt32BE(packet, 0, p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  // 'ssh-userauth' service-specific\n  authFailure(authMethods, isPartial) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    let methods;\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n    if (authMethods) {\n      methods = [];\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none') continue;\n        methods.push(authMethods[i]);\n      }\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n    packet[p += methodsLen] = isPartial === true ? 1 : 0;\n    this._authsQueue.shift();\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authSuccess() {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n    this._authsQueue.shift();\n    this._authenticated = true;\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n  }\n  authPKOK(keyAlgo, key) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey') throw new Error('\"publickey\" auth not in progress');\n\n    // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n    this._authsQueue.shift();\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPasswdChg(prompt) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n    for (let i = 0; i < prompts.length; ++i) promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n    writeUInt32BE(packet, 0, p);\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n      packet[p++] = prompt.echo ? 1 : 0;\n    }\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n}\n\n// SSH-protoversion-softwareversion (SP comments) CR LF\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;\n\n// TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer, chunk.byteOffset + p, len - p), this._buffer.length);\n    }\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n    if (ch === 13 /* '\\r' */) {\n      needNL = true;\n      continue;\n    }\n    if (ch === 10 /* '\\n' */) {\n      if (end > start && end - start > 4 && data[start] === 83 /* 'S' */ && data[start + 1] === 83 /* 'S' */ && data[start + 2] === 72 /* 'H' */ && data[start + 3] === 45 /* '-' */) {\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = start === op ? full : full.slice(start - op);\n        const m = RE_IDENT.exec(identRaw);\n        if (!m) throw new Error('Invalid identification string');\n        const header = {\n          greeting: start === op ? '' : full.slice(0, start - op),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2]\n          },\n          comments: m[3]\n        };\n\n        // Needed during handshake\n        this._remoteIdentRaw = Buffer.from(identRaw);\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n        this._buffer = undefined;\n        this._decipher = new NullDecipher(0, onKEXPayload.bind(this, {\n          firstPacket: true\n        }));\n        this._parse = parsePacket;\n        this._onHeader(header);\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n        kexinit(this);\n        return p + 1 - chunkOffset;\n      }\n\n      // Only allow pre-ident greetings when we're a client\n      if (this._server) throw new Error('Greetings from clients not permitted');\n      if (++lines > MAX_LINES) throw new Error('Max greeting lines exceeded');\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n    end = p;\n  }\n  if (!this._buffer) this._buffer = bufferSlice(data, op);\n  return p - chunkOffset;\n}\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n\n  this._onPacket();\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n  if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n  }\n  const handler = MESSAGE_HANDLERS[type];\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n  return handler(this, payload);\n}\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n  let flags = 0;\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0]) flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n  return flags;\n}\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe(5 * keys.length + 1);\n  let b = 0;\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END') continue;\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined) continue;\n    const val = modes[key];\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n  if (b < bytes.length) return bufferSlice(bytes, 0, b);\n  return bytes;\n}\nmodule.exports = Protocol;","map":{"version":3,"names":["inspect","require","bindingAvailable","NullCipher","NullDecipher","COMPAT_CHECKS","DISCONNECT_REASON","MESSAGE","SIGNALS","TERMINAL_MODE","DEFAULT_KEXINIT","KexInit","kexinit","onKEXPayload","parseKey","MESSAGE_HANDLERS","bufferCopy","bufferFill","bufferSlice","convertSignature","sendPacket","writeUInt32BE","PacketReader","PacketWriter","ZlibPacketReader","ZlibPacketWriter","MODULE_VER","version","VALID_DISCONNECT_REASONS","Map","Object","values","map","n","IDENT_RAW","Buffer","from","IDENT","MAX_LINE_LEN","MAX_LINES","PING_PAYLOAD","GLOBAL_REQUEST","NO_TERMINAL_MODES_BUFFER","TTY_OP_END","noop","Protocol","constructor","config","_this","onWrite","Error","_onWrite","data","onError","_onError","err","debug","_debug","msg","undefined","onHeader","_onHeader","arguments","onPacket","_onPacket","onHandshakeComplete","_onHandshakeComplete","oldQueue","_queue","length","i","finalized","_packetRW","write","finalize","packet","_cipher","allocPacket","set","messageHandlers","_handlers","_onPayload","onPayload","bind","_server","server","_banner","greeting","hostKeys","_hostKeys","slice","banner","offer","_kex","_kexinit","_offer","_decipher","_skipNextInboundPacket","read","_hostVerifier","hostVerifier","_parse","parseHeader","_buffer","_authsQueue","_authenticated","_remoteIdentRaw","sentIdent","ident","_identRaw","allocUnsafe","isBuffer","fullIdent","latin1Write","_compatFlags","toString","start","_destruct","reason","cleanup","free","parse","chunk","len","disconnect","pktLen","p","allocStartKEX","alloc","end","has","PROTOCOL_ERROR","DISCONNECT","fill","ping","allocStart","rekey","requestSuccess","REQUEST_SUCCESS","requestFailure","REQUEST_FAILURE","channelSuccess","chan","CHANNEL_SUCCESS","channelFailure","CHANNEL_FAILURE","channelEOF","CHANNEL_EOF","channelClose","CHANNEL_CLOSE","channelWindowAdjust","amount","CHANNEL_WINDOW_ADJUST","channelData","dataLen","byteLength","CHANNEL_DATA","utf8Write","channelExtData","type","CHANNEL_EXTENDED_DATA","channelOpenConfirm","remote","local","initWindow","maxPacket","CHANNEL_OPEN_CONFIRMATION","channelOpenFail","desc","descLen","CHANNEL_OPEN_FAILURE","service","name","nameLen","SERVICE_REQUEST","authPassword","username","password","newPassword","userLen","passLen","newPassLen","USERAUTH_REQUEST","push","authPK","pubKey","cbSign","keyType","getPublicSSH","algoLen","pubKeyLen","sessionID","sesLen","payloadLen","signature","sigLen","authHostbased","hostname","userlocal","hostnameLen","userlocalLen","reqDataLen","authKeyboard","authNone","authInfoRes","responses","responsesTotalLen","responseLens","Array","USERAUTH_INFO_RESPONSE","tcpipForward","bindAddr","bindPort","wantReply","addrLen","cancelTcpipForward","openssh_streamLocalForward","socketPath","socketPathLen","openssh_cancelStreamLocalForward","directTcpip","cfg","srcLen","srcIP","dstLen","dstIP","CHANNEL_OPEN","dstPort","srcPort","openssh_directStreamLocal","pathLen","openssh_noMoreSessions","session","windowChange","rows","cols","height","width","CHANNEL_REQUEST","pty","term","modes","isArray","modesToBytes","termLen","modesLen","shell","exec","cmd","isBuf","cmdLen","signal","origSignal","toUpperCase","signalLen","env","key","val","keyLen","valLen","x11Forward","protocol","cookie","isBufProto","protoLen","isBufCookie","cookieLen","single","screen","subsystem","openssh_agentForward","openssh_hostKeysProve","keys","keysTotal","publicKeys","publicKey","buf","serviceAccept","svcName","svcNameLen","SERVICE_ACCEPT","bannerLen","USERAUTH_BANNER","forwardedTcpip","boundAddrLen","boundAddr","remoteAddrLen","remoteAddr","boundPort","remotePort","x11","originAddr","originPort","openssh_authAgent","openssh_forwardedStreamLocal","exitStatus","status","exitSignal","coreDumped","msgLen","authFailure","authMethods","isPartial","methods","toLowerCase","join","methodsLen","USERAUTH_FAILURE","shift","authSuccess","USERAUTH_SUCCESS","negotiated","cs","compress","sc","authPKOK","keyAlgo","keyAlgoLen","USERAUTH_PK_OK","authPasswdChg","prompt","promptLen","USERAUTH_PASSWD_CHANGEREQ","authInfoReq","instructions","prompts","promptsLen","instrLen","USERAUTH_INFO_REQUEST","echo","RE_IDENT","chunkOffset","Uint8Array","buffer","byteOffset","op","needNL","lineLen","lines","ch","full","latin1Slice","identRaw","m","header","versions","software","comments","getCompatFlags","firstPacket","parsePacket","decrypt","payload","handler","flags","rule","test","bytes","b","opcode","isFinite","module","exports"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/protocol/Protocol.js"],"sourcesContent":["/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n\n'use strict';\n\nconst { inspect } = require('util');\n\nconst { bindingAvailable, NullCipher, NullDecipher } = require('./crypto.js');\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE,\n} = require('./constants.js');\nconst {\n  DEFAULT_KEXINIT,\n  KexInit,\n  kexinit,\n  onKEXPayload,\n} = require('./kex.js');\nconst {\n  parseKey,\n} = require('./keyParser.js');\nconst MESSAGE_HANDLERS = require('./handlers.js');\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE,\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n} = require('./zlib.js');\n\nconst MODULE_VER = require('../../package.json').version;\n\nconst VALID_DISCONNECT_REASONS = new Map(\n  Object.values(DISCONNECT_REASON).map((n) => [n, 1])\n);\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1,\n]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([ TERMINAL_MODE.TTY_OP_END ]);\n\nfunction noop() {}\n\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\nclass Protocol {\n  constructor(config) {\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function')\n      throw new Error('Missing onWrite function');\n    this._onWrite = (data) => { onWrite(data); };\n\n    const onError = config.onError;\n    if (typeof onError !== 'function')\n      throw new Error('Missing onError function');\n    this._onError = (err) => { onError(err); };\n\n    const debug = config.debug;\n    this._debug = (typeof debug === 'function'\n                   ? (msg) => { debug(msg); }\n                   : undefined);\n\n    const onHeader = config.onHeader;\n    this._onHeader = (typeof onHeader === 'function'\n                      ? (...args) => { onHeader(...args); }\n                      : noop);\n\n    const onPacket = config.onPacket;\n    this._onPacket = (typeof onPacket === 'function'\n                      ? () => { onPacket(); }\n                      : noop);\n\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function')\n      onHandshakeComplete = noop;\n    this._onHandshakeComplete = (...args) => {\n      this._debug && this._debug('Handshake completed');\n\n      // Process packets queued during a rekey where necessary\n      const oldQueue = this._queue;\n      if (oldQueue) {\n        this._queue = undefined;\n        this._debug && this._debug(\n          `Draining outbound queue (${oldQueue.length}) ...`\n        );\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i];\n          // data === payload only\n\n          // XXX: hacky\n          let finalized = this._packetRW.write.finalize(data);\n          if (finalized === data) {\n            const packet = this._cipher.allocPacket(data.length);\n            packet.set(data, 5);\n            finalized = packet;\n          }\n\n          sendPacket(this, finalized);\n        }\n        this._debug && this._debug('... finished draining outbound queue');\n      }\n\n      onHandshakeComplete(...args);\n    };\n    this._queue = undefined;\n\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null)\n      this._handlers = messageHandlers;\n    else\n      this._handlers = {};\n\n    this._onPayload = onPayload.bind(this);\n\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null)\n        throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys;\n\n      // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = (config.greeting.slice(-2) === '\\r\\n'\n                    ? config.greeting\n                    : `${config.greeting}\\r\\n`);\n      }\n\n      // Banner shown after the handshake completes, but before user\n      // authentication begins\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = (config.banner.slice(-2) === '\\r\\n'\n                        ? config.banner\n                        : `${config.banner}\\r\\n`);\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null)\n      offer = DEFAULT_KEXINIT;\n    else if (offer.constructor !== KexInit)\n      offer = new KexInit(offer);\n    this._kex = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this),\n    };\n    this._hostVerifier = (!this._server\n                           && typeof config.hostVerifier === 'function'\n                          ? config.hostVerifier\n                          : undefined);\n\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n    this._compatFlags = 0;\n\n    if (this._debug) {\n      if (bindingAvailable)\n        this._debug('Custom crypto binding available');\n      else\n        this._debug('Custom crypto binding not available');\n    }\n\n    this._debug && this._debug(\n      `Local ident: ${inspect(this._identRaw.toString())}`\n    );\n    this.start = () => {\n      this.start = undefined;\n      if (greeting)\n        this._onWrite(greeting);\n      this._onWrite(sentIdent);\n    };\n  }\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n    this._packetRW.write.cleanup();\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0)\n      reason = 'fatal error';\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._destruct = undefined;\n  }\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n  parse(chunk, i, len) {\n    while (i < len)\n      i = this._parse(chunk, i, len);\n  }\n\n  // Protocol message API\n\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4;\n    // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n    let p = this._packetRW.write.allocStartKEX;\n    const packet = this._packetRW.write.alloc(pktLen, true);\n    const end = p + pktLen;\n\n    if (!VALID_DISCONNECT_REASONS.has(reason))\n      reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n  ping() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n\n    packet.set(PING_PAYLOAD, p);\n\n    this._debug && this._debug(\n      'Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelSuccess(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelFailure(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelEOF(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_EOF;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelClose(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, amount, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_DATA;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, dataLen, p += 4);\n\n    if (isBuffer)\n      packet.set(data, p += 4);\n    else\n      packet.utf8Write(data, p += 4, dataLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, type, p += 4);\n\n    writeUInt32BE(packet, dataLen, p += 4);\n\n    if (isBuffer)\n      packet.set(data, p += 4);\n    else\n      packet.utf8Write(data, p += 4, dataLen);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n    writeUInt32BE(packet, remote, ++p);\n\n    writeUInt32BE(packet, local, p += 4);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string')\n      desc = '';\n\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n    writeUInt32BE(packet, remote, ++p);\n\n    writeUInt32BE(packet, reason, p += 4);\n\n    writeUInt32BE(packet, descLen, p += 4);\n\n    p += 4;\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  service(name) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-userauth' service-specific\n  // -------------------------------\n  authPassword(username, password, newPassword) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = (newPassword ? Buffer.byteLength(newPassword) : 0);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen\n        + (newPassword ? 4 + newPassLen : 0)\n    );\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n\n    packet[p += 8] = (newPassword ? 1 : 0);\n\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password))\n      bufferCopy(password, packet, 0, passLen, p += 4);\n    else\n      packet.utf8Write(password, p += 4, passLen);\n\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword))\n        bufferCopy(newPassword, packet, 0, newPassLen, p += 4);\n      else\n        packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (changed password)'\n      );\n    } else {\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (password)'\n      );\n    }\n\n    this._authsQueue.push('password');\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPK(username, pubKey, cbSign) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error)\n      throw new Error('Invalid key');\n\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen =\n      (cbSign ? 4 + sesLen : 0)\n        + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n\n    packet[p += 9] = (cbSign ? 1 : 0);\n\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyType, p += 4, algoLen);\n\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (publickey -- check)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n\n    cbSign(packet, (signature) => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false)\n        throw new Error('Error while converting handshake signature');\n\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(\n        1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4\n          + 4 + algoLen + 4 + sigLen\n      );\n\n      // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n\n      packet[p += 9] = 1;\n\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyType, p += 4, algoLen);\n\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (publickey)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authHostbased(username, pubKey, hostname, userlocal, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error)\n      throw new Error('Invalid key');\n\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(\n      4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen\n        + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen\n    );\n    let p = 0;\n\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyType, p += 4, algoLen);\n\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n\n    cbSign(data, (signature) => {\n      signature = convertSignature(signature, keyType);\n      if (!signature)\n        throw new Error('Error while converting handshake signature');\n\n      const sigLen = signature.length;\n      const reqDataLen = (data.length - sesLen - 4);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(\n        reqDataLen + 4 + 4 + algoLen + 4 + sigLen\n      );\n\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      this._authsQueue.push('hostbased');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (hostbased)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authKeyboard(username) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4\n    );\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n\n    writeUInt32BE(packet, 0, p += 20);\n\n    writeUInt32BE(packet, 0, p += 4);\n\n    this._authsQueue.push('keyboard-interactive');\n\n    this._debug && this._debug(\n      'Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authNone(username) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n\n    this._authsQueue.push('none');\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoRes(responses) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let responsesTotalLen = 0;\n    let responseLens;\n\n    if (responses) {\n      responseLens = new Array(responses.length);\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n\n    packet[p += 13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, bindPort, p += addrLen);\n\n    this._debug\n      && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n\n    packet[p += 20] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, bindPort, p += addrLen);\n\n    this._debug\n      && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 31 + 1 + 4 + socketPathLen\n    );\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n\n    packet[p += 31] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    this._debug && this._debug(\n      'Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 38 + 1 + 4 + socketPathLen\n    );\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n\n    packet[p += 38] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending GLOBAL_REQUEST '\n          + '(cancel-streamlocal-forward@openssh.com)'\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n\n    writeUInt32BE(packet, chan, p += 12);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n\n    writeUInt32BE(packet, chan, p += 30);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    // zero-fill reserved fields (string and uint32)\n    bufferFill(packet, 0, p += pathLen, p + 8);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_OPEN '\n          + `(r:${chan}, direct-streamlocal@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_noMoreSessions(wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n\n    packet[p += 28] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    this._debug && this._debug(\n      'Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  session(chan, initWindow, maxPacket) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n\n    writeUInt32BE(packet, chan, p += 7);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n\n    packet[p += 13] = 0;\n\n    writeUInt32BE(packet, cols, ++p);\n\n    writeUInt32BE(packet, rows, p += 4);\n\n    writeUInt32BE(packet, width, p += 4);\n\n    writeUInt32BE(packet, height, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    if (!term || !term.length)\n      term = 'vt100';\n    if (modes\n        && !Buffer.isBuffer(modes)\n        && !Array.isArray(modes)\n        && typeof modes === 'object'\n        && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n    if (!modes || !modes.length)\n      modes = NO_TERMINAL_MODES_BUFFER;\n\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n\n    packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n\n    writeUInt32BE(packet, cols, p += termLen);\n\n    writeUInt32BE(packet, rows, p += 4);\n\n    writeUInt32BE(packet, width, p += 4);\n\n    writeUInt32BE(packet, height, p += 4);\n\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i)\n        packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  shell(chan, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n\n    packet[p += 5] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exec(chan, cmd, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = (isBuf ? cmd.length : Buffer.byteLength(cmd));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n\n    packet[p += 4] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf)\n      packet.set(cmd, p += 4);\n    else\n      packet.utf8Write(cmd, p += 4, cmdLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  signal(chan, signal) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const origSignal = signal;\n\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG')\n      signal = signal.slice(3);\n\n    if (SIGNALS[signal] !== 1)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 6 + 1 + 4 + signalLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n\n    packet[p += 6] = 0;\n\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  env(chan, key, val, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = (isBuf ? val.length : Buffer.byteLength(val));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n\n    packet[p += 3] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf)\n      packet.set(val, p += 4);\n    else\n      packet.utf8Write(val, p += 4, valLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = (isBufProto\n                      ? protocol.length\n                      : Buffer.byteLength(protocol));\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = (isBufCookie\n                       ? cookie.length\n                       : Buffer.byteLength(cookie));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n\n    packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    packet[++p] = (cfg.single ? 1 : 0);\n\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto)\n      packet.set(protocol, p += 4);\n    else\n      packet.utf8Write(protocol, p += 4, protoLen);\n\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie)\n      packet.set(cookie, p += 4);\n    else\n      packet.latin1Write(cookie, p += 4, cookieLen);\n\n    writeUInt32BE(packet, (cfg.screen || 0), p += cookieLen);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  subsystem(chan, name, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n\n    packet[p += 9] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_agentForward(chan, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n\n    packet[p += 26] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_REQUEST '\n          + `(r:${chan}, auth-agent-req@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_hostKeysProve(keys) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let keysTotal = 0;\n    const publicKeys = [];\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)'\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  serviceAccept(svcName) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  }\n  // 'ssh-connection' service-specific\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n\n    writeUInt32BE(packet, chan, p += 15);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n\n    writeUInt32BE(packet, chan, p += 3);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n\n    writeUInt32BE(packet, chan, p += 22);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n\n    writeUInt32BE(packet, chan, p += 33);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    writeUInt32BE(packet, 0, p += pathLen);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_OPEN '\n          + `(r:${chan}, forwarded-streamlocal@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitStatus(chan, status) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n\n    packet[p += 11] = 0;\n\n    writeUInt32BE(packet, status, ++p);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n\n    const origSignal = name;\n\n    if (typeof origSignal !== 'string' || !origSignal)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG')\n      signal = signal.slice(3);\n\n    if (SIGNALS[signal] !== 1)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = (msg ? Buffer.byteLength(msg) : 0);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n\n    packet[p += 11] = 0;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n\n    packet[p += nameLen] = (coreDumped ? 1 : 0);\n\n    writeUInt32BE(packet, msgLen, ++p);\n\n    p += 4;\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  // 'ssh-userauth' service-specific\n  authFailure(authMethods, isPartial) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0)\n      throw new Error('No auth in progress');\n\n    let methods;\n\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n\n    if (authMethods) {\n      methods = [];\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none')\n          continue;\n        methods.push(authMethods[i]);\n      }\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n\n    packet[p += methodsLen] = (isPartial === true ? 1 : 0);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authSuccess() {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0)\n      throw new Error('No auth in progress');\n\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n\n    this._authsQueue.shift();\n    this._authenticated = true;\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')\n      this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')\n      this._packetRW.write = new ZlibPacketWriter(this);\n  }\n  authPKOK(keyAlgo, key) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey')\n      throw new Error('\"publickey\" auth not in progress');\n\n    // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPasswdChg(prompt) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n\n    for (let i = 0; i < prompts.length; ++i)\n      promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen\n    );\n\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n      packet[p++] = (prompt.echo ? 1 : 0);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n}\n\n// SSH-protoversion-softwareversion (SP comments) CR LF\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;\n\n// TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer,\n                              chunk.byteOffset + p,\n                              (len - p)),\n               this._buffer.length);\n    }\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n\n    if (ch === 13 /* '\\r' */) {\n      needNL = true;\n      continue;\n    }\n\n    if (ch === 10 /* '\\n' */) {\n      if (end > start\n          && end - start > 4\n          && data[start] === 83 /* 'S' */\n          && data[start + 1] === 83 /* 'S' */\n          && data[start + 2] === 72 /* 'H' */\n          && data[start + 3] === 45 /* '-' */) {\n\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = (start === op ? full : full.slice(start - op));\n        const m = RE_IDENT.exec(identRaw);\n        if (!m)\n          throw new Error('Invalid identification string');\n\n        const header = {\n          greeting: (start === op ? '' : full.slice(0, start - op)),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2],\n          },\n          comments: m[3]\n        };\n\n        // Needed during handshake\n        this._remoteIdentRaw = Buffer.from(identRaw);\n\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n\n        this._buffer = undefined;\n        this._decipher =\n          new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));\n        this._parse = parsePacket;\n\n        this._onHeader(header);\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n\n        kexinit(this);\n\n        return p + 1 - chunkOffset;\n      }\n\n      // Only allow pre-ident greetings when we're a client\n      if (this._server)\n        throw new Error('Greetings from clients not permitted');\n\n      if (++lines > MAX_LINES)\n        throw new Error('Max greeting lines exceeded');\n\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n\n    end = p;\n  }\n  if (!this._buffer)\n    this._buffer = bufferSlice(data, op);\n\n  return p - chunkOffset;\n}\n\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\n\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n\n  this._onPacket();\n\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n\n  const type = payload[0];\n  if (type === MESSAGE.USERAUTH_SUCCESS\n      && !this._server\n      && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')\n      this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')\n      this._packetRW.read = new ZlibPacketReader();\n  }\n  const handler = MESSAGE_HANDLERS[type];\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n\n  return handler(this, payload);\n}\n\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n\n  let flags = 0;\n\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0])\n        flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n\n  return flags;\n}\n\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe((5 * keys.length) + 1);\n  let b = 0;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END')\n      continue;\n\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined)\n      continue;\n\n    const val = modes[key];\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n\n  if (b < bytes.length)\n    return bufferSlice(bytes, 0, b);\n\n  return bytes;\n}\n\nmodule.exports = Protocol;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst MAX_CHANNEL = 2 ** 32 - 1;\nfunction onChannelOpenFailure(self, recipient, info, cb) {\n  self._chanMgr.remove(recipient);\n  if (typeof cb !== 'function') return;\n  let err;\n  if (info instanceof Error) {\n    err = info;\n  } else if (typeof info === 'object' && info !== null) {\n    err = new Error(`(SSH) Channel open failure: ${info.description}`);\n    err.reason = info.reason;\n  } else {\n    err = new Error('(SSH) Channel open failure: server closed channel unexpectedly');\n    err.reason = '';\n  }\n  cb(err);\n}\nfunction onCHANNEL_CLOSE(self, recipient, channel, err, dead) {\n  if (typeof channel === 'function') {\n    // We got CHANNEL_CLOSE instead of CHANNEL_OPEN_FAILURE when\n    // requesting to open a channel\n    onChannelOpenFailure(self, recipient, err, channel);\n    return;\n  }\n  if (typeof channel !== 'object' || channel === null) return;\n  if (channel.incoming && channel.incoming.state === 'closed') return;\n  self._chanMgr.remove(recipient);\n  if (channel.server && channel.constructor.name === 'Session') return;\n  channel.incoming.state = 'closed';\n  if (channel.readable) channel.push(null);\n  if (channel.server) {\n    if (channel.stderr.writable) channel.stderr.end();\n  } else if (channel.stderr.readable) {\n    channel.stderr.push(null);\n  }\n  if (channel.constructor !== SFTP && (channel.outgoing.state === 'open' || channel.outgoing.state === 'eof') && !dead) {\n    channel.close();\n  }\n  if (channel.outgoing.state === 'closing') channel.outgoing.state = 'closed';\n  const readState = channel._readableState;\n  const writeState = channel._writableState;\n  if (writeState && !writeState.ending && !writeState.finished && !dead) channel.end();\n\n  // Take care of any outstanding channel requests\n  const chanCallbacks = channel._callbacks;\n  channel._callbacks = [];\n  for (let i = 0; i < chanCallbacks.length; ++i) chanCallbacks[i](true);\n  if (channel.server) {\n    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {\n      channel.emit('close');\n    } else {\n      channel.once('end', () => channel.emit('close'));\n    }\n  } else {\n    let doClose;\n    switch (channel.type) {\n      case 'direct-streamlocal@openssh.com':\n      case 'direct-tcpip':\n        doClose = () => channel.emit('close');\n        break;\n      default:\n        {\n          // Align more with node child processes, where the close event gets\n          // the same arguments as the exit event\n          const exit = channel._exit;\n          doClose = () => {\n            if (exit.code === null) channel.emit('close', exit.code, exit.signal, exit.dump, exit.desc);else channel.emit('close', exit.code);\n          };\n        }\n    }\n    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {\n      doClose();\n    } else {\n      channel.once('end', doClose);\n    }\n    const errReadState = channel.stderr._readableState;\n    if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {\n      channel.stderr.emit('close');\n    } else {\n      channel.stderr.once('end', () => channel.stderr.emit('close'));\n    }\n  }\n}\nclass ChannelManager {\n  constructor(client) {\n    this._client = client;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n  }\n  add(val) {\n    // Attempt to reserve an id\n\n    let id;\n    // Optimized paths\n    if (this._cur < MAX_CHANNEL) {\n      id = ++this._cur;\n    } else if (this._count === 0) {\n      // Revert and reset back to fast path once we no longer have any channels\n      // open\n      this._cur = 0;\n      id = 0;\n    } else {\n      // Slower lookup path\n\n      // This path is triggered we have opened at least MAX_CHANNEL channels\n      // while having at least one channel open at any given time, so we have\n      // to search for a free id.\n      const channels = this._channels;\n      for (let i = 0; i < MAX_CHANNEL; ++i) {\n        if (channels[i] === undefined) {\n          id = i;\n          break;\n        }\n      }\n    }\n    if (id === undefined) return -1;\n    this._channels[id] = val || true;\n    ++this._count;\n    return id;\n  }\n  update(id, val) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    if (val && this._channels[id]) this._channels[id] = val;\n  }\n  get(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    return this._channels[id];\n  }\n  remove(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    if (this._channels[id]) {\n      delete this._channels[id];\n      if (this._count) --this._count;\n    }\n  }\n  cleanup(err) {\n    const channels = this._channels;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n    const chanIDs = Object.keys(channels);\n    const client = this._client;\n    for (let i = 0; i < chanIDs.length; ++i) {\n      const id = +chanIDs[i];\n      const channel = channels[id];\n      onCHANNEL_CLOSE(client, id, channel._channel || channel, err, true);\n    }\n  }\n}\nconst isRegExp = (() => {\n  const toString = Object.prototype.toString;\n  return val => toString.call(val) === '[object RegExp]';\n})();\nfunction generateAlgorithmList(algoList, defaultList, supportedList) {\n  if (Array.isArray(algoList) && algoList.length > 0) {\n    // Exact list\n    for (let i = 0; i < algoList.length; ++i) {\n      if (supportedList.indexOf(algoList[i]) === -1) throw new Error(`Unsupported algorithm: ${algoList[i]}`);\n    }\n    return algoList;\n  }\n  if (typeof algoList === 'object' && algoList !== null) {\n    // Operations based on the default list\n    const keys = Object.keys(algoList);\n    let list = defaultList;\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      let val = algoList[key];\n      switch (key) {\n        case 'append':\n          if (!Array.isArray(val)) val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const append = val[j];\n              if (typeof append === 'string') {\n                if (!append || list.indexOf(append) !== -1) continue;\n                if (supportedList.indexOf(append) === -1) throw new Error(`Unsupported algorithm: ${append}`);\n                if (list === defaultList) list = list.slice();\n                list.push(append);\n              } else if (isRegExp(append)) {\n                for (let k = 0; k < supportedList.length; ++k) {\n                  const algo = supportedList[k];\n                  if (append.test(algo)) {\n                    if (list.indexOf(algo) !== -1) continue;\n                    if (list === defaultList) list = list.slice();\n                    list.push(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'prepend':\n          if (!Array.isArray(val)) val = [val];\n          if (Array.isArray(val)) {\n            for (let j = val.length; j >= 0; --j) {\n              const prepend = val[j];\n              if (typeof prepend === 'string') {\n                if (!prepend || list.indexOf(prepend) !== -1) continue;\n                if (supportedList.indexOf(prepend) === -1) throw new Error(`Unsupported algorithm: ${prepend}`);\n                if (list === defaultList) list = list.slice();\n                list.unshift(prepend);\n              } else if (isRegExp(prepend)) {\n                for (let k = supportedList.length; k >= 0; --k) {\n                  const algo = supportedList[k];\n                  if (prepend.test(algo)) {\n                    if (list.indexOf(algo) !== -1) continue;\n                    if (list === defaultList) list = list.slice();\n                    list.unshift(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'remove':\n          if (!Array.isArray(val)) val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const search = val[j];\n              if (typeof search === 'string') {\n                if (!search) continue;\n                const idx = list.indexOf(search);\n                if (idx === -1) continue;\n                if (list === defaultList) list = list.slice();\n                list.splice(idx, 1);\n              } else if (isRegExp(search)) {\n                for (let k = 0; k < list.length; ++k) {\n                  if (search.test(list[k])) {\n                    if (list === defaultList) list = list.slice();\n                    list.splice(k, 1);\n                    --k;\n                  }\n                }\n              }\n            }\n          }\n          break;\n      }\n    }\n    return list;\n  }\n  return defaultList;\n}\nmodule.exports = {\n  ChannelManager,\n  generateAlgorithmList,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n  isWritable: stream => {\n    // XXX: hack to workaround regression in node\n    // See: https://github.com/nodejs/node/issues/36029\n    return stream && stream.writable && stream._readableState && stream._readableState.ended === false;\n  }\n};","map":{"version":3,"names":["SFTP","require","MAX_CHANNEL","onChannelOpenFailure","self","recipient","info","cb","_chanMgr","remove","err","Error","description","reason","onCHANNEL_CLOSE","channel","dead","incoming","state","server","constructor","name","readable","push","stderr","writable","end","outgoing","close","readState","_readableState","writeState","_writableState","ending","finished","chanCallbacks","_callbacks","i","length","destroyed","endEmitted","emit","once","doClose","type","exit","_exit","code","signal","dump","desc","errReadState","ChannelManager","client","_client","_channels","_cur","_count","add","val","id","channels","undefined","update","isFinite","get","cleanup","chanIDs","Object","keys","_channel","isRegExp","toString","prototype","call","generateAlgorithmList","algoList","defaultList","supportedList","Array","isArray","indexOf","list","key","j","append","slice","k","algo","test","prepend","unshift","search","idx","splice","module","exports","isWritable","stream","ended"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/utils.js"],"sourcesContent":["'use strict';\n\nconst { SFTP } = require('./protocol/SFTP.js');\n\nconst MAX_CHANNEL = 2 ** 32 - 1;\n\nfunction onChannelOpenFailure(self, recipient, info, cb) {\n  self._chanMgr.remove(recipient);\n  if (typeof cb !== 'function')\n    return;\n\n  let err;\n  if (info instanceof Error) {\n    err = info;\n  } else if (typeof info === 'object' && info !== null) {\n    err = new Error(`(SSH) Channel open failure: ${info.description}`);\n    err.reason = info.reason;\n  } else {\n    err = new Error(\n      '(SSH) Channel open failure: server closed channel unexpectedly'\n    );\n    err.reason = '';\n  }\n\n  cb(err);\n}\n\nfunction onCHANNEL_CLOSE(self, recipient, channel, err, dead) {\n  if (typeof channel === 'function') {\n    // We got CHANNEL_CLOSE instead of CHANNEL_OPEN_FAILURE when\n    // requesting to open a channel\n    onChannelOpenFailure(self, recipient, err, channel);\n    return;\n  }\n\n  if (typeof channel !== 'object' || channel === null)\n    return;\n\n  if (channel.incoming && channel.incoming.state === 'closed')\n    return;\n\n  self._chanMgr.remove(recipient);\n\n  if (channel.server && channel.constructor.name === 'Session')\n    return;\n\n  channel.incoming.state = 'closed';\n\n  if (channel.readable)\n    channel.push(null);\n  if (channel.server) {\n    if (channel.stderr.writable)\n      channel.stderr.end();\n  } else if (channel.stderr.readable) {\n    channel.stderr.push(null);\n  }\n\n  if (channel.constructor !== SFTP\n      && (channel.outgoing.state === 'open'\n          || channel.outgoing.state === 'eof')\n      && !dead) {\n    channel.close();\n  }\n  if (channel.outgoing.state === 'closing')\n    channel.outgoing.state = 'closed';\n\n  const readState = channel._readableState;\n  const writeState = channel._writableState;\n  if (writeState && !writeState.ending && !writeState.finished && !dead)\n    channel.end();\n\n  // Take care of any outstanding channel requests\n  const chanCallbacks = channel._callbacks;\n  channel._callbacks = [];\n  for (let i = 0; i < chanCallbacks.length; ++i)\n    chanCallbacks[i](true);\n\n  if (channel.server) {\n    if (!channel.readable\n        || channel.destroyed\n        || (readState && readState.endEmitted)) {\n      channel.emit('close');\n    } else {\n      channel.once('end', () => channel.emit('close'));\n    }\n  } else {\n    let doClose;\n    switch (channel.type) {\n      case 'direct-streamlocal@openssh.com':\n      case 'direct-tcpip':\n        doClose = () => channel.emit('close');\n        break;\n      default: {\n        // Align more with node child processes, where the close event gets\n        // the same arguments as the exit event\n        const exit = channel._exit;\n        doClose = () => {\n          if (exit.code === null)\n            channel.emit('close', exit.code, exit.signal, exit.dump, exit.desc);\n          else\n            channel.emit('close', exit.code);\n        };\n      }\n    }\n    if (!channel.readable\n        || channel.destroyed\n        || (readState && readState.endEmitted)) {\n      doClose();\n    } else {\n      channel.once('end', doClose);\n    }\n\n    const errReadState = channel.stderr._readableState;\n    if (!channel.stderr.readable\n        || channel.stderr.destroyed\n        || (errReadState && errReadState.endEmitted)) {\n      channel.stderr.emit('close');\n    } else {\n      channel.stderr.once('end', () => channel.stderr.emit('close'));\n    }\n  }\n}\n\nclass ChannelManager {\n  constructor(client) {\n    this._client = client;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n  }\n  add(val) {\n    // Attempt to reserve an id\n\n    let id;\n    // Optimized paths\n    if (this._cur < MAX_CHANNEL) {\n      id = ++this._cur;\n    } else if (this._count === 0) {\n      // Revert and reset back to fast path once we no longer have any channels\n      // open\n      this._cur = 0;\n      id = 0;\n    } else {\n      // Slower lookup path\n\n      // This path is triggered we have opened at least MAX_CHANNEL channels\n      // while having at least one channel open at any given time, so we have\n      // to search for a free id.\n      const channels = this._channels;\n      for (let i = 0; i < MAX_CHANNEL; ++i) {\n        if (channels[i] === undefined) {\n          id = i;\n          break;\n        }\n      }\n    }\n\n    if (id === undefined)\n      return -1;\n\n    this._channels[id] = (val || true);\n    ++this._count;\n\n    return id;\n  }\n  update(id, val) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))\n      throw new Error(`Invalid channel id: ${id}`);\n\n    if (val && this._channels[id])\n      this._channels[id] = val;\n  }\n  get(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))\n      throw new Error(`Invalid channel id: ${id}`);\n\n    return this._channels[id];\n  }\n  remove(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))\n      throw new Error(`Invalid channel id: ${id}`);\n\n    if (this._channels[id]) {\n      delete this._channels[id];\n      if (this._count)\n        --this._count;\n    }\n  }\n  cleanup(err) {\n    const channels = this._channels;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n\n    const chanIDs = Object.keys(channels);\n    const client = this._client;\n    for (let i = 0; i < chanIDs.length; ++i) {\n      const id = +chanIDs[i];\n      const channel = channels[id];\n      onCHANNEL_CLOSE(client, id, channel._channel || channel, err, true);\n    }\n  }\n}\n\nconst isRegExp = (() => {\n  const toString = Object.prototype.toString;\n  return (val) => toString.call(val) === '[object RegExp]';\n})();\n\nfunction generateAlgorithmList(algoList, defaultList, supportedList) {\n  if (Array.isArray(algoList) && algoList.length > 0) {\n    // Exact list\n    for (let i = 0; i < algoList.length; ++i) {\n      if (supportedList.indexOf(algoList[i]) === -1)\n        throw new Error(`Unsupported algorithm: ${algoList[i]}`);\n    }\n    return algoList;\n  }\n\n  if (typeof algoList === 'object' && algoList !== null) {\n    // Operations based on the default list\n    const keys = Object.keys(algoList);\n    let list = defaultList;\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      let val = algoList[key];\n      switch (key) {\n        case 'append':\n          if (!Array.isArray(val))\n            val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const append = val[j];\n              if (typeof append === 'string') {\n                if (!append || list.indexOf(append) !== -1)\n                  continue;\n                if (supportedList.indexOf(append) === -1)\n                  throw new Error(`Unsupported algorithm: ${append}`);\n                if (list === defaultList)\n                  list = list.slice();\n                list.push(append);\n              } else if (isRegExp(append)) {\n                for (let k = 0; k < supportedList.length; ++k) {\n                  const algo = supportedList[k];\n                  if (append.test(algo)) {\n                    if (list.indexOf(algo) !== -1)\n                      continue;\n                    if (list === defaultList)\n                      list = list.slice();\n                    list.push(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'prepend':\n          if (!Array.isArray(val))\n            val = [val];\n          if (Array.isArray(val)) {\n            for (let j = val.length; j >= 0; --j) {\n              const prepend = val[j];\n              if (typeof prepend === 'string') {\n                if (!prepend || list.indexOf(prepend) !== -1)\n                  continue;\n                if (supportedList.indexOf(prepend) === -1)\n                  throw new Error(`Unsupported algorithm: ${prepend}`);\n                if (list === defaultList)\n                  list = list.slice();\n                list.unshift(prepend);\n              } else if (isRegExp(prepend)) {\n                for (let k = supportedList.length; k >= 0; --k) {\n                  const algo = supportedList[k];\n                  if (prepend.test(algo)) {\n                    if (list.indexOf(algo) !== -1)\n                      continue;\n                    if (list === defaultList)\n                      list = list.slice();\n                    list.unshift(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'remove':\n          if (!Array.isArray(val))\n            val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const search = val[j];\n              if (typeof search === 'string') {\n                if (!search)\n                  continue;\n                const idx = list.indexOf(search);\n                if (idx === -1)\n                  continue;\n                if (list === defaultList)\n                  list = list.slice();\n                list.splice(idx, 1);\n              } else if (isRegExp(search)) {\n                for (let k = 0; k < list.length; ++k) {\n                  if (search.test(list[k])) {\n                    if (list === defaultList)\n                      list = list.slice();\n                    list.splice(k, 1);\n                    --k;\n                  }\n                }\n              }\n            }\n          }\n          break;\n      }\n    }\n\n    return list;\n  }\n\n  return defaultList;\n}\n\nmodule.exports = {\n  ChannelManager,\n  generateAlgorithmList,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n  isWritable: (stream) => {\n    // XXX: hack to workaround regression in node\n    // See: https://github.com/nodejs/node/issues/36029\n    return (stream\n            && stream.writable\n            && stream._readableState\n            && stream._readableState.ended === false);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
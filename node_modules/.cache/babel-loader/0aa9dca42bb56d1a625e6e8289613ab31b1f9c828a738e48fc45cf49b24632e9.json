{"ast":null,"code":"// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n'use strict';\n\nconst {\n  createDecipheriv,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  sign: sign_,\n  verify: verify_\n} = require('crypto');\nconst supportedOpenSSLCiphers = getCiphers();\nconst {\n  Ber\n} = require('asn1');\nconst bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\nconst {\n  CIPHER_INFO\n} = require('./crypto.js');\nconst {\n  eddsaSupported,\n  SUPPORTED_CIPHER\n} = require('./constants.js');\nconst {\n  bufferSlice,\n  makeBufferParser,\n  readString,\n  readUInt32BE,\n  writeUInt32BE\n} = require('./utils.js');\nconst SYM_HASH_ALGO = Symbol('Hash Algorithm');\nconst SYM_PRIV_PEM = Symbol('Private key PEM');\nconst SYM_PUB_PEM = Symbol('Public key PEM');\nconst SYM_PUB_SSH = Symbol('Public key SSH');\nconst SYM_DECRYPTED = Symbol('Decrypted Key');\n\n// Create OpenSSL cipher name -> SSH cipher name conversion table\nconst CIPHER_INFO_OPENSSL = Object.create(null);\n{\n  const keys = Object.keys(CIPHER_INFO);\n  for (let i = 0; i < keys.length; ++i) {\n    const cipherName = CIPHER_INFO[keys[i]].sslName;\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName]) continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n}\nconst binaryKeyParser = makeBufferParser();\nfunction makePEM(type, data) {\n  data = data.base64Slice(0, data.length);\n  let formatted = data.replace(/.{64}/g, '$&\\n');\n  if (data.length & 63) formatted += '\\n';\n  return `-----BEGIN ${type} KEY-----\\n${formatted}-----END ${type} KEY-----`;\n}\nfunction combineBuffers(buf1, buf2) {\n  const result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  result.set(buf1, 0);\n  result.set(buf2, buf1.length);\n  return result;\n}\nfunction skipFields(buf, nfields) {\n  const bufLen = buf.length;\n  let pos = buf._pos || 0;\n  for (let i = 0; i < nfields; ++i) {\n    const left = bufLen - pos;\n    if (pos >= bufLen || left < 4) return false;\n    const len = readUInt32BE(buf, pos);\n    if (left < 4 + len) return false;\n    pos += 4 + len;\n  }\n  buf._pos = pos;\n  return true;\n}\nfunction genOpenSSLRSAPub(n, e) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n  // algorithm parameters (RSA has none)\n  asnWriter.writeNull();\n  asnWriter.endSequence();\n\n  // subjectPublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(n, Ber.Integer);\n  asnWriter.writeBuffer(e, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHRSAPub(n, e) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-rsa', 4, 7);\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  publicKey.set(e, i += 4);\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  publicKey.set(n, i + 4);\n  return publicKey;\n}\nconst genOpenSSLRSAPriv = (() => {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    const asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(n, Ber.Integer);\n    asnWriter.writeBuffer(e, Ber.Integer);\n    asnWriter.writeBuffer(d, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(dmp1, Ber.Integer);\n    asnWriter.writeBuffer(dmq1, Ber.Integer);\n    asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n  function bigIntFromBuffer(buf) {\n    return BigInt(`0x${buf.hexSlice(0, buf.length)}`);\n  }\n  function bigIntToBuffer(bn) {\n    let hex = bn.toString(16);\n    if ((hex.length & 1) !== 0) {\n      hex = `0${hex}`;\n    } else {\n      const sigbit = hex.charCodeAt(0);\n      // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n      if (sigbit === 56 /* '8' */ || sigbit === 57 /* '9' */ || sigbit >= 97 /* 'a' */ && sigbit <= 102 /* 'f' */) {\n        hex = `00${hex}`;\n      }\n    }\n    return Buffer.from(hex, 'hex');\n  }\n  return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n    const bn_d = bigIntFromBuffer(d);\n    const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));\n    const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));\n    return makePEM('RSA PRIVATE', genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n  };\n})();\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n  // algorithm parameters\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(p, Ber.Integer);\n  asnWriter.writeBuffer(q, Ber.Integer);\n  asnWriter.writeBuffer(g, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n\n  // subjectPublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  asnWriter.writeBuffer(y, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length);\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-dss', 4, 7);\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  publicKey.set(p, i += 4);\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  publicKey.set(q, i += 4);\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  publicKey.set(g, i += 4);\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  publicKey.set(y, i + 4);\n  return publicKey;\n}\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  asnWriter.writeInt(0x00, Ber.Integer);\n  asnWriter.writeBuffer(p, Ber.Integer);\n  asnWriter.writeBuffer(q, Ber.Integer);\n  asnWriter.writeBuffer(g, Ber.Integer);\n  asnWriter.writeBuffer(y, Ber.Integer);\n  asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\nfunction genOpenSSLEdPub(pub) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n  asnWriter.endSequence();\n\n  // PublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  // XXX: hack to write a raw buffer without a tag -- yuck\n  asnWriter._ensure(pub.length);\n  asnWriter._buf.set(pub, asnWriter._offset);\n  asnWriter._offset += pub.length;\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHEdPub(pub) {\n  const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.utf8Write('ssh-ed25519', 4, 11);\n  writeUInt32BE(publicKey, pub.length, 15);\n  publicKey.set(pub, 19);\n  return publicKey;\n}\nfunction genOpenSSLEdPriv(priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // version\n  asnWriter.writeInt(0x00, Ber.Integer);\n\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n  asnWriter.endSequence();\n\n  // PrivateKey\n  asnWriter.startSequence(Ber.OctetString);\n  asnWriter.writeBuffer(priv, Ber.OctetString);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\nfunction genOpenSSLECDSAPub(oid, Q) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n  // algorithm parameters (namedCurve)\n  asnWriter.writeOID(oid);\n  asnWriter.endSequence();\n\n  // subjectPublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  // XXX: hack to write a raw buffer without a tag -- yuck\n  asnWriter._ensure(Q.length);\n  asnWriter._buf.set(Q, asnWriter._offset);\n  asnWriter._offset += Q.length;\n  // end hack\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHECDSAPub(oid, Q) {\n  let curveName;\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n    default:\n      return;\n  }\n  const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.utf8Write(curveName, 27, 8);\n  writeUInt32BE(publicKey, Q.length, 35);\n  publicKey.set(Q, 39);\n  return publicKey;\n}\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // version\n  asnWriter.writeInt(0x01, Ber.Integer);\n  // privateKey\n  asnWriter.writeBuffer(priv, Ber.OctetString);\n  // parameters (optional)\n  asnWriter.startSequence(0xA0);\n  asnWriter.writeOID(oid);\n  asnWriter.endSequence();\n  // publicKey (optional)\n  asnWriter.startSequence(0xA1);\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  // XXX: hack to write a raw buffer without a tag -- yuck\n  asnWriter._ensure(pub.length);\n  asnWriter._buf.set(pub, asnWriter._offset);\n  asnWriter._offset += pub.length;\n  // end hack\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  const tempECDH = createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\nconst BaseKey = {\n  sign: (() => {\n    if (typeof sign_ === 'function') {\n      return function sign(data, algo) {\n        const pem = this[SYM_PRIV_PEM];\n        if (pem === null) return new Error('No private key available');\n        if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n        try {\n          return sign_(algo, data, pem);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function sign(data, algo) {\n      const pem = this[SYM_PRIV_PEM];\n      if (pem === null) return new Error('No private key available');\n      if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n      const signature = createSign(algo);\n      signature.update(data);\n      try {\n        return signature.sign(pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  verify: (() => {\n    if (typeof verify_ === 'function') {\n      return function verify(data, signature, algo) {\n        const pem = this[SYM_PUB_PEM];\n        if (pem === null) return new Error('No public key available');\n        if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n        try {\n          return verify_(algo, data, pem, signature);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function verify(data, signature, algo) {\n      const pem = this[SYM_PUB_PEM];\n      if (pem === null) return new Error('No public key available');\n      if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n      const verifier = createVerify(algo);\n      verifier.update(data);\n      try {\n        return verifier.verify(pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  isPrivateKey: function isPrivateKey() {\n    return this[SYM_PRIV_PEM] !== null;\n  },\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n  equals: function equals(key) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) return false;\n    return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH];\n  }\n};\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n  OpenSSH_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    let ret;\n    const data = Buffer.from(m[1], 'base64');\n    if (data.length < 31)\n      // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    const magic = data.utf8Slice(0, 15);\n    if (magic !== 'openssh-key-v1\\0') return new Error(`Unsupported OpenSSH key magic: ${magic}`);\n    const cipherName = readString(data, 15, true);\n    if (cipherName === undefined) return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1) return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);\n    const kdfName = readString(data, data._pos, true);\n    if (kdfName === undefined) return new Error('Malformed OpenSSH private key');\n    if (kdfName !== 'none') {\n      if (cipherName === 'none') return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt') return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);\n      if (!passphrase) {\n        return new Error('Encrypted private OpenSSH key detected, but no passphrase given');\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n    let encInfo;\n    let cipherKey;\n    let cipherIV;\n    if (cipherName !== 'none') encInfo = CIPHER_INFO[cipherName];\n    const kdfOptions = readString(data, data._pos);\n    if (kdfOptions === undefined) return new Error('Malformed OpenSSH private key');\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n        case 'bcrypt':\n          /*\n            string salt\n            uint32 rounds\n          */\n          const salt = readString(kdfOptions, 0);\n          if (salt === undefined || kdfOptions._pos + 4 > kdfOptions.length) return new Error('Malformed OpenSSH private key');\n          const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n          const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n          const r = bcrypt_pbkdf(passphrase, passphrase.length, salt, salt.length, gen, gen.length, rounds);\n          if (r !== 0) return new Error('Failed to generate information to decrypt key');\n          cipherKey = bufferSlice(gen, 0, encInfo.keyLen);\n          cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);\n          break;\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n    if (data._pos + 3 >= data.length) return new Error('Malformed OpenSSH private key');\n    const keyCount = readUInt32BE(data, data._pos);\n    data._pos += 4;\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n\n      // Read public keys first\n      for (let i = 0; i < keyCount; ++i) {\n        const pubData = readString(data, data._pos);\n        if (pubData === undefined) return new Error('Malformed OpenSSH private key');\n        const type = readString(pubData, 0, true);\n        if (type === undefined) return new Error('Malformed OpenSSH private key');\n      }\n      let privBlob = readString(data, data._pos);\n      if (privBlob === undefined) return new Error('Malformed OpenSSH private key');\n      if (cipherKey !== undefined) {\n        // Encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n        try {\n          const options = {\n            authTagLength: encInfo.authLen\n          };\n          const decipher = createDecipheriv(encInfo.sslName, cipherKey, cipherIV, options);\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen) return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(bufferSlice(data, data._pos, data._pos += encInfo.authLen));\n          }\n          privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      }\n      // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n      if (data._pos !== data.length) return new Error('Malformed OpenSSH private key');\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n    if (ret instanceof Error) return ret;\n    // This will need to change if/when OpenSSH ever starts storing multiple\n    // keys in their key files\n    return ret[0];\n  };\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    const keys = [];\n    /*\n      uint32  checkint\n      uint32  checkint\n      string  privatekey1\n      string  comment1\n      string  privatekey2\n      string  comment2\n      ...\n      string  privatekeyN\n      string  commentN\n      char  1\n      char  2\n      char  3\n      ...\n      char  padlen % 255\n    */\n    if (data.length < 8) return new Error('Malformed OpenSSH private key');\n    const check1 = readUInt32BE(data, 0);\n    const check2 = readUInt32BE(data, 4);\n    if (check1 !== check2) {\n      if (decrypted) {\n        return new Error('OpenSSH key integrity check failed -- bad passphrase?');\n      }\n      return new Error('OpenSSH key integrity check failed');\n    }\n    data._pos = 8;\n    let i;\n    let oid;\n    for (i = 0; i < nkeys; ++i) {\n      let algo;\n      let privPEM;\n      let pubPEM;\n      let pubSSH;\n      // The OpenSSH documentation for the key format actually lies, the\n      // entirety of the private key content is not contained with a string\n      // field, it's actually the literal contents of the private key, so to be\n      // able to find the end of the key data you need to know the layout/format\n      // of each key type ...\n      const type = readString(data, data._pos, true);\n      if (type === undefined) return new Error('Malformed OpenSSH private key');\n      switch (type) {\n        case 'ssh-rsa':\n          {\n            /*\n              string  n -- public\n              string  e -- public\n              string  d -- private\n              string  iqmp -- private\n              string  p -- private\n              string  q -- private\n            */\n            const n = readString(data, data._pos);\n            if (n === undefined) return new Error('Malformed OpenSSH private key');\n            const e = readString(data, data._pos);\n            if (e === undefined) return new Error('Malformed OpenSSH private key');\n            const d = readString(data, data._pos);\n            if (d === undefined) return new Error('Malformed OpenSSH private key');\n            const iqmp = readString(data, data._pos);\n            if (iqmp === undefined) return new Error('Malformed OpenSSH private key');\n            const p = readString(data, data._pos);\n            if (p === undefined) return new Error('Malformed OpenSSH private key');\n            const q = readString(data, data._pos);\n            if (q === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLRSAPub(n, e);\n            pubSSH = genOpenSSHRSAPub(n, e);\n            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n            algo = 'sha1';\n            break;\n          }\n        case 'ssh-dss':\n          {\n            /*\n              string  p -- public\n              string  q -- public\n              string  g -- public\n              string  y -- public\n              string  x -- private\n            */\n            const p = readString(data, data._pos);\n            if (p === undefined) return new Error('Malformed OpenSSH private key');\n            const q = readString(data, data._pos);\n            if (q === undefined) return new Error('Malformed OpenSSH private key');\n            const g = readString(data, data._pos);\n            if (g === undefined) return new Error('Malformed OpenSSH private key');\n            const y = readString(data, data._pos);\n            if (y === undefined) return new Error('Malformed OpenSSH private key');\n            const x = readString(data, data._pos);\n            if (x === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLDSAPub(p, q, g, y);\n            pubSSH = genOpenSSHDSAPub(p, q, g, y);\n            privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n            algo = 'sha1';\n            break;\n          }\n        case 'ssh-ed25519':\n          {\n            if (!eddsaSupported) return new Error(`Unsupported OpenSSH private key type: ${type}`);\n            /*\n              * string  public key\n              * string  private key + public key\n            */\n            const edpub = readString(data, data._pos);\n            if (edpub === undefined || edpub.length !== 32) return new Error('Malformed OpenSSH private key');\n            const edpriv = readString(data, data._pos);\n            if (edpriv === undefined || edpriv.length !== 64) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLEdPub(edpub);\n            pubSSH = genOpenSSHEdPub(edpub);\n            privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));\n            algo = null;\n            break;\n          }\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp521':\n          {\n            if (algo === undefined) {\n              algo = 'sha512';\n              oid = '1.3.132.0.35';\n            }\n            /*\n              string  curve name\n              string  Q -- public\n              string  d -- private\n            */\n            // TODO: validate curve name against type\n            if (!skipFields(data, 1))\n              // Skip curve name\n              return new Error('Malformed OpenSSH private key');\n            const ecpub = readString(data, data._pos);\n            if (ecpub === undefined) return new Error('Malformed OpenSSH private key');\n            const ecpriv = readString(data, data._pos);\n            if (ecpriv === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n            pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n            privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n            break;\n          }\n        default:\n          return new Error(`Unsupported OpenSSH private key type: ${type}`);\n      }\n      const privComment = readString(data, data._pos, true);\n      if (privComment === undefined) return new Error('Malformed OpenSSH private key');\n      keys.push(new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo, decrypted));\n    }\n    let cnt = 0;\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== ++cnt % 255) return new Error('Malformed OpenSSH private key');\n    }\n    return keys;\n  }\n}\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Old_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n  OpenSSH_Old_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    let privBlob = Buffer.from(m[3], 'base64');\n    let headers = m[2];\n    let decrypted = false;\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n      for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        let sepIdx = header.indexOf(':');\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          const val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1) continue;\n          const cipherName = val.slice(0, sepIdx).toLowerCase();\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(`Cipher (${cipherName}) not supported ` + 'for encrypted OpenSSH private key');\n          }\n          const encInfo = CIPHER_INFO_OPENSSL[cipherName];\n          if (!encInfo) {\n            return new Error(`Cipher (${cipherName}) not supported ` + 'for encrypted OpenSSH private key');\n          }\n          const cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen) return new Error('Malformed encrypted OpenSSH private key');\n          if (!passphrase) {\n            return new Error('Encrypted OpenSSH private key detected, but no passphrase given');\n          }\n          const ivSlice = bufferSlice(cipherIV, 0, 8);\n          let cipherKey = createHash('md5').update(passphrase).update(ivSlice).digest();\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(cipherKey, createHash('md5').update(cipherKey).update(passphrase).update(ivSlice).digest());\n          }\n          if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n          try {\n            const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n    let type;\n    let privPEM;\n    let pubPEM;\n    let pubSSH;\n    let algo;\n    let reader;\n    let errMsg = 'Malformed OpenSSH private key';\n    if (decrypted) errMsg += '. Bad passphrase?';\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const n = reader.readString(Ber.Integer, true);\n          if (n === null) return new Error(errMsg);\n          const e = reader.readString(Ber.Integer, true);\n          if (e === null) return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const p = reader.readString(Ber.Integer, true);\n          if (p === null) return new Error(errMsg);\n          const q = reader.readString(Ber.Integer, true);\n          if (q === null) return new Error(errMsg);\n          const g = reader.readString(Ber.Integer, true);\n          if (g === null) return new Error(errMsg);\n          const y = reader.readString(Ber.Integer, true);\n          if (y === null) return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'EC':\n        let ecSSLName;\n        let ecPriv;\n        let ecOID;\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          ecPriv = reader.readString(Ber.OctetString, true);\n          reader.readByte(); // Skip \"complex\" context type byte\n          const offset = reader.readLength(); // Skip context length\n          if (offset !== null) {\n            reader._offset = offset;\n            ecOID = reader.readOID();\n            if (ecOID === null) return new Error(errMsg);\n            switch (ecOID) {\n              case '1.2.840.10045.3.1.7':\n                // prime256v1/secp256r1\n                ecSSLName = 'prime256v1';\n                type = 'ecdsa-sha2-nistp256';\n                algo = 'sha256';\n                break;\n              case '1.3.132.0.34':\n                // secp384r1\n                ecSSLName = 'secp384r1';\n                type = 'ecdsa-sha2-nistp384';\n                algo = 'sha384';\n                break;\n              case '1.3.132.0.35':\n                // secp521r1\n                ecSSLName = 'secp521r1';\n                type = 'ecdsa-sha2-nistp521';\n                algo = 'sha512';\n                break;\n              default:\n                return new Error(`Unsupported private key EC OID: ${ecOID}`);\n            }\n          } else {\n            return new Error(errMsg);\n          }\n        } catch {\n          return new Error(errMsg);\n        }\n        privPEM = makePEM('EC PRIVATE', privBlob);\n        const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n        pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);\n        pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);\n        break;\n    }\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo, decrypted);\n  };\n}\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nPPK_Private.prototype = BaseKey;\n{\n  const EMPTY_PASSPHRASE = Buffer.alloc(0);\n  const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  const PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  const PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n  PPK_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n    const cipherName = m[2];\n    const encrypted = cipherName !== 'none';\n    if (encrypted && !passphrase) {\n      return new Error('Encrypted PPK private key detected, but no passphrase given');\n    }\n    let privBlob = Buffer.from(m[5], 'base64');\n    if (encrypted) {\n      const encInfo = CIPHER_INFO[cipherName];\n      let cipherKey = combineBuffers(createHash('sha1').update(PPK_PP1).update(passphrase).digest(), createHash('sha1').update(PPK_PP2).update(passphrase).digest());\n      if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n      try {\n        const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n      } catch (ex) {\n        return ex;\n      }\n    }\n    const type = m[1];\n    const comment = m[3];\n    const pubBlob = Buffer.from(m[4], 'base64');\n    const mac = m[6];\n    const typeLen = type.length;\n    const cipherNameLen = cipherName.length;\n    const commentLen = Buffer.byteLength(comment);\n    const pubLen = pubBlob.length;\n    const privLen = privBlob.length;\n    const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);\n    let p = 0;\n    writeUInt32BE(macData, typeLen, p);\n    macData.utf8Write(type, p += 4, typeLen);\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.utf8Write(cipherName, p += 4, cipherNameLen);\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.utf8Write(comment, p += 4, commentLen);\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    macData.set(pubBlob, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    macData.set(privBlob, p + 4);\n    if (!passphrase) passphrase = EMPTY_PASSPHRASE;\n    const calcMAC = createHmac('sha1', createHash('sha1').update('putty-private-key-file-mac-key').update(passphrase).digest()).update(macData).digest('hex');\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error('PPK private key integrity check failed -- bad passphrase?');\n      }\n      return new Error('PPK private key integrity check failed');\n    }\n    let pubPEM;\n    let pubSSH;\n    let privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n    switch (type) {\n      case 'ssh-rsa':\n        {\n          const e = readString(pubBlob, pubBlob._pos);\n          if (e === undefined) return new Error('Malformed PPK public key');\n          const n = readString(pubBlob, pubBlob._pos);\n          if (n === undefined) return new Error('Malformed PPK public key');\n          const d = readString(privBlob, 0);\n          if (d === undefined) return new Error('Malformed PPK private key');\n          const p = readString(privBlob, privBlob._pos);\n          if (p === undefined) return new Error('Malformed PPK private key');\n          const q = readString(privBlob, privBlob._pos);\n          if (q === undefined) return new Error('Malformed PPK private key');\n          const iqmp = readString(privBlob, privBlob._pos);\n          if (iqmp === undefined) return new Error('Malformed PPK private key');\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          break;\n        }\n      case 'ssh-dss':\n        {\n          const p = readString(pubBlob, pubBlob._pos);\n          if (p === undefined) return new Error('Malformed PPK public key');\n          const q = readString(pubBlob, pubBlob._pos);\n          if (q === undefined) return new Error('Malformed PPK public key');\n          const g = readString(pubBlob, pubBlob._pos);\n          if (g === undefined) return new Error('Malformed PPK public key');\n          const y = readString(pubBlob, pubBlob._pos);\n          if (y === undefined) return new Error('Malformed PPK public key');\n          const x = readString(privBlob, 0);\n          if (x === undefined) return new Error('Malformed PPK private key');\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          break;\n        }\n    }\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1', encrypted);\n  };\n}\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nOpenSSH_Public.prototype = BaseKey;\n{\n  let regexp;\n  if (eddsaSupported) regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;else regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  OpenSSH_Public.parse = str => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    const fullType = m[1];\n    const baseType = m[2];\n    const data = Buffer.from(m[3], 'base64');\n    const comment = m[4] || '';\n    const type = readString(data, data._pos, true);\n    if (type === undefined || type.indexOf(baseType) !== 0) return new Error('Malformed OpenSSH public key');\n    return parseDER(data, baseType, comment, fullType);\n  };\n}\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nRFC4716_Public.prototype = BaseKey;\n{\n  const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r?\\n)((?:.{0,72}\\r?\\n)+)---- END SSH2 PUBLIC KEY ----$/;\n  const RE_DATA = /^[A-Z0-9a-z/+=\\r\\n]+$/;\n  const RE_HEADER = /^([\\x21-\\x39\\x3B-\\x7E]{1,64}): ((?:[^\\\\]*\\\\\\r?\\n)*[^\\r\\n]+)\\r?\\n/gm;\n  const RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n  RFC4716_Public.parse = str => {\n    let m = regexp.exec(str);\n    if (m === null) return null;\n    const body = m[1];\n    let dataStart = 0;\n    let comment = '';\n    while (m = RE_HEADER.exec(body)) {\n      const headerName = m[1];\n      const headerValue = m[2].replace(RE_HEADER_ENDS, '');\n      if (headerValue.length > 1024) {\n        RE_HEADER.lastIndex = 0;\n        return new Error('Malformed RFC4716 public key');\n      }\n      dataStart = RE_HEADER.lastIndex;\n      if (headerName.toLowerCase() === 'comment') {\n        comment = headerValue;\n        if (comment.length > 1 && comment.charCodeAt(0) === 34 /* '\"' */ && comment.charCodeAt(comment.length - 1) === 34 /* '\"' */) {\n          comment = comment.slice(1, -1);\n        }\n      }\n    }\n    let data = body.slice(dataStart);\n    if (!RE_DATA.test(data)) return new Error('Malformed RFC4716 public key');\n    data = Buffer.from(data, 'base64');\n    const type = readString(data, 0, true);\n    if (type === undefined) return new Error('Malformed RFC4716 public key');\n    let pubPEM = null;\n    let pubSSH = null;\n    switch (type) {\n      case 'ssh-rsa':\n        {\n          const e = readString(data, data._pos);\n          if (e === undefined) return new Error('Malformed RFC4716 public key');\n          const n = readString(data, data._pos);\n          if (n === undefined) return new Error('Malformed RFC4716 public key');\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          break;\n        }\n      case 'ssh-dss':\n        {\n          const p = readString(data, data._pos);\n          if (p === undefined) return new Error('Malformed RFC4716 public key');\n          const q = readString(data, data._pos);\n          if (q === undefined) return new Error('Malformed RFC4716 public key');\n          const g = readString(data, data._pos);\n          if (g === undefined) return new Error('Malformed RFC4716 public key');\n          const y = readString(data, data._pos);\n          if (y === undefined) return new Error('Malformed RFC4716 public key');\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          break;\n        }\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n}\nfunction parseDER(data, baseType, comment, fullType) {\n  if (!isSupportedKeyType(baseType)) return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  let algo;\n  let oid;\n  let pubPEM = null;\n  let pubSSH = null;\n  switch (baseType) {\n    case 'ssh-rsa':\n      {\n        const e = readString(data, data._pos || 0);\n        if (e === undefined) return new Error('Malformed OpenSSH public key');\n        const n = readString(data, data._pos);\n        if (n === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        algo = 'sha1';\n        break;\n      }\n    case 'ssh-dss':\n      {\n        const p = readString(data, data._pos || 0);\n        if (p === undefined) return new Error('Malformed OpenSSH public key');\n        const q = readString(data, data._pos);\n        if (q === undefined) return new Error('Malformed OpenSSH public key');\n        const g = readString(data, data._pos);\n        if (g === undefined) return new Error('Malformed OpenSSH public key');\n        const y = readString(data, data._pos);\n        if (y === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        algo = 'sha1';\n        break;\n      }\n    case 'ssh-ed25519':\n      {\n        const edpub = readString(data, data._pos || 0);\n        if (edpub === undefined || edpub.length !== 32) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLEdPub(edpub);\n        pubSSH = genOpenSSHEdPub(edpub);\n        algo = null;\n        break;\n      }\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp521':\n      {\n        if (algo === undefined) {\n          algo = 'sha512';\n          oid = '1.3.132.0.35';\n        }\n        // TODO: validate curve name against type\n        if (!skipFields(data, 1))\n          // Skip curve name\n          return new Error('Malformed OpenSSH public key');\n        const ecpub = readString(data, data._pos || 0);\n        if (ecpub === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n        pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n        break;\n      }\n    default:\n      return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  }\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\nfunction isSupportedKeyType(type) {\n  switch (type) {\n    case 'ssh-rsa':\n    case 'ssh-dss':\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return true;\n    case 'ssh-ed25519':\n      if (eddsaSupported) return true;\n    // FALLTHROUGH\n    default:\n      return false;\n  }\n}\nfunction isParsedKey(val) {\n  if (!val) return false;\n  return typeof val[SYM_DECRYPTED] === 'boolean';\n}\nfunction parseKey(data, passphrase) {\n  if (isParsedKey(data)) return data;\n  let origBuffer;\n  if (Buffer.isBuffer(data)) {\n    origBuffer = data;\n    data = data.utf8Slice(0, data.length).trim();\n  } else if (typeof data === 'string') {\n    data = data.trim();\n  } else {\n    return new Error('Key data must be a Buffer or string');\n  }\n\n  // eslint-disable-next-line eqeqeq\n  if (passphrase != undefined) {\n    if (typeof passphrase === 'string') passphrase = Buffer.from(passphrase);else if (!Buffer.isBuffer(passphrase)) return new Error('Passphrase must be a string or Buffer when supplied');\n  }\n  let ret;\n\n  // First try as printable string format (e.g. PEM)\n\n  // Private keys\n  if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null) return ret;\n  if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null) return ret;\n  if ((ret = PPK_Private.parse(data, passphrase)) !== null) return ret;\n\n  // Public keys\n  if ((ret = OpenSSH_Public.parse(data)) !== null) return ret;\n  if ((ret = RFC4716_Public.parse(data)) !== null) return ret;\n\n  // Finally try as a binary format if we were originally passed binary data\n  if (origBuffer) {\n    binaryKeyParser.init(origBuffer, 0);\n    const type = binaryKeyParser.readString(true);\n    if (type !== undefined) {\n      data = binaryKeyParser.readRaw();\n      if (data !== undefined) {\n        ret = parseDER(data, type, '', type);\n        // Ignore potentially useless errors in case the data was not actually\n        // in the binary format\n        if (ret instanceof Error) ret = null;\n      }\n    }\n    binaryKeyParser.clear();\n  }\n  if (ret) return ret;\n  return new Error('Unsupported key format');\n}\nmodule.exports = {\n  isParsedKey,\n  isSupportedKeyType,\n  parseDERKey: (data, type) => parseDER(data, type, '', type),\n  parseKey\n};","map":{"version":3,"names":["createDecipheriv","createECDH","createHash","createHmac","createSign","createVerify","getCiphers","sign","sign_","verify","verify_","require","supportedOpenSSLCiphers","Ber","bcrypt_pbkdf","pbkdf","CIPHER_INFO","eddsaSupported","SUPPORTED_CIPHER","bufferSlice","makeBufferParser","readString","readUInt32BE","writeUInt32BE","SYM_HASH_ALGO","Symbol","SYM_PRIV_PEM","SYM_PUB_PEM","SYM_PUB_SSH","SYM_DECRYPTED","CIPHER_INFO_OPENSSL","Object","create","keys","i","length","cipherName","sslName","binaryKeyParser","makePEM","type","data","base64Slice","formatted","replace","combineBuffers","buf1","buf2","result","Buffer","allocUnsafe","set","skipFields","buf","nfields","bufLen","pos","_pos","left","len","genOpenSSLRSAPub","n","e","asnWriter","Writer","startSequence","writeOID","writeNull","endSequence","BitString","writeByte","writeBuffer","Integer","buffer","genOpenSSHRSAPub","publicKey","utf8Write","genOpenSSLRSAPriv","genRSAASN1Buf","d","p","q","dmp1","dmq1","iqmp","writeInt","bigIntFromBuffer","BigInt","hexSlice","bigIntToBuffer","bn","hex","toString","sigbit","charCodeAt","from","bn_d","genOpenSSLDSAPub","g","y","genOpenSSHDSAPub","genOpenSSLDSAPriv","x","genOpenSSLEdPub","pub","_ensure","_buf","_offset","genOpenSSHEdPub","genOpenSSLEdPriv","priv","OctetString","genOpenSSLECDSAPub","oid","Q","genOpenSSHECDSAPub","curveName","genOpenSSLECDSAPriv","genOpenSSLECDSAPubFromPriv","tempECDH","setPrivateKey","getPublicKey","BaseKey","algo","pem","Error","ex","signature","update","verifier","isPrivateKey","getPrivatePEM","getPublicPEM","getPublicSSH","equals","key","parsed","parseKey","OpenSSH_Private","comment","privPEM","pubPEM","pubSSH","decrypted","prototype","regexp","parse","str","passphrase","m","exec","ret","magic","utf8Slice","undefined","indexOf","kdfName","encInfo","cipherKey","cipherIV","kdfOptions","salt","rounds","gen","keyLen","ivLen","r","keyCount","pubData","privBlob","blockLen","options","authTagLength","authLen","decipher","setAuthTag","final","parseOpenSSHPrivKeys","nkeys","check1","check2","edpub","edpriv","ecpub","ecpriv","privComment","push","cnt","OpenSSH_Old_Private","headers","split","header","sepIdx","slice","val","toLowerCase","ivSlice","digest","setAutoPadding","reader","errMsg","Reader","readSequence","readInt","ecSSLName","ecPriv","ecOID","readByte","offset","readLength","readOID","pubBlob","PPK_Private","EMPTY_PASSPHRASE","alloc","PPK_IV","PPK_PP1","PPK_PP2","encrypted","mac","typeLen","cipherNameLen","commentLen","byteLength","pubLen","privLen","macData","calcMAC","OpenSSH_Public","fullType","baseType","parseDER","RFC4716_Public","RE_DATA","RE_HEADER","RE_HEADER_ENDS","body","dataStart","headerName","headerValue","lastIndex","test","isSupportedKeyType","isParsedKey","origBuffer","isBuffer","trim","init","readRaw","clear","module","exports","parseDERKey"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/protocol/keyParser.js"],"sourcesContent":["// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n'use strict';\n\nconst {\n  createDecipheriv,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  sign: sign_,\n  verify: verify_,\n} = require('crypto');\nconst supportedOpenSSLCiphers = getCiphers();\n\nconst { Ber } = require('asn1');\nconst bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\n\nconst { CIPHER_INFO } = require('./crypto.js');\nconst { eddsaSupported, SUPPORTED_CIPHER } = require('./constants.js');\nconst {\n  bufferSlice,\n  makeBufferParser,\n  readString,\n  readUInt32BE,\n  writeUInt32BE,\n} = require('./utils.js');\n\nconst SYM_HASH_ALGO = Symbol('Hash Algorithm');\nconst SYM_PRIV_PEM = Symbol('Private key PEM');\nconst SYM_PUB_PEM = Symbol('Public key PEM');\nconst SYM_PUB_SSH = Symbol('Public key SSH');\nconst SYM_DECRYPTED = Symbol('Decrypted Key');\n\n// Create OpenSSL cipher name -> SSH cipher name conversion table\nconst CIPHER_INFO_OPENSSL = Object.create(null);\n{\n  const keys = Object.keys(CIPHER_INFO);\n  for (let i = 0; i < keys.length; ++i) {\n    const cipherName = CIPHER_INFO[keys[i]].sslName;\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])\n      continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n}\n\nconst binaryKeyParser = makeBufferParser();\n\nfunction makePEM(type, data) {\n  data = data.base64Slice(0, data.length);\n  let formatted = data.replace(/.{64}/g, '$&\\n');\n  if (data.length & 63)\n    formatted += '\\n';\n  return `-----BEGIN ${type} KEY-----\\n${formatted}-----END ${type} KEY-----`;\n}\n\nfunction combineBuffers(buf1, buf2) {\n  const result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  result.set(buf1, 0);\n  result.set(buf2, buf1.length);\n  return result;\n}\n\nfunction skipFields(buf, nfields) {\n  const bufLen = buf.length;\n  let pos = (buf._pos || 0);\n  for (let i = 0; i < nfields; ++i) {\n    const left = (bufLen - pos);\n    if (pos >= bufLen || left < 4)\n      return false;\n    const len = readUInt32BE(buf, pos);\n    if (left < 4 + len)\n      return false;\n    pos += 4 + len;\n  }\n  buf._pos = pos;\n  return true;\n}\n\nfunction genOpenSSLRSAPub(n, e) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n      // algorithm parameters (RSA has none)\n      asnWriter.writeNull();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(n, Ber.Integer);\n        asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHRSAPub(n, e) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-rsa', 4, 7);\n\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  publicKey.set(e, i += 4);\n\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  publicKey.set(n, i + 4);\n\n  return publicKey;\n}\n\nconst genOpenSSLRSAPriv = (() => {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    const asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(n, Ber.Integer);\n      asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.writeBuffer(d, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(dmp1, Ber.Integer);\n      asnWriter.writeBuffer(dmq1, Ber.Integer);\n      asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n\n  function bigIntFromBuffer(buf) {\n    return BigInt(`0x${buf.hexSlice(0, buf.length)}`);\n  }\n\n  function bigIntToBuffer(bn) {\n    let hex = bn.toString(16);\n    if ((hex.length & 1) !== 0) {\n      hex = `0${hex}`;\n    } else {\n      const sigbit = hex.charCodeAt(0);\n      // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n      if (sigbit === 56/* '8' */\n          || sigbit === 57/* '9' */\n          || (sigbit >= 97/* 'a' */ && sigbit <= 102/* 'f' */)) {\n        hex = `00${hex}`;\n      }\n    }\n    return Buffer.from(hex, 'hex');\n  }\n\n  return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n    const bn_d = bigIntFromBuffer(d);\n    const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));\n    const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));\n    return makePEM('RSA PRIVATE',\n                   genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n  };\n})();\n\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n      // algorithm parameters\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(p, Ber.Integer);\n        asnWriter.writeBuffer(q, Ber.Integer);\n        asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  const publicKey = Buffer.allocUnsafe(\n    4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length\n  );\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-dss', 4, 7);\n\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  publicKey.set(p, i += 4);\n\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  publicKey.set(q, i += 4);\n\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  publicKey.set(g, i += 4);\n\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  publicKey.set(y, i + 4);\n\n  return publicKey;\n}\n\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(g, Ber.Integer);\n    asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLEdPub(pub) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(pub.length);\n      asnWriter._buf.set(pub, asnWriter._offset);\n      asnWriter._offset += pub.length;\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHEdPub(pub) {\n  const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);\n\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.utf8Write('ssh-ed25519', 4, 11);\n\n  writeUInt32BE(publicKey, pub.length, 15);\n  publicKey.set(pub, 19);\n\n  return publicKey;\n}\n\nfunction genOpenSSLEdPriv(priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x00, Ber.Integer);\n\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PrivateKey\n    asnWriter.startSequence(Ber.OctetString);\n      asnWriter.writeBuffer(priv, Ber.OctetString);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPub(oid, Q) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n      // algorithm parameters (namedCurve)\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(Q.length);\n      asnWriter._buf.set(Q, asnWriter._offset);\n      asnWriter._offset += Q.length;\n      // end hack\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHECDSAPub(oid, Q) {\n  let curveName;\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n    default:\n      return;\n  }\n\n  const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);\n\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);\n\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.utf8Write(curveName, 27, 8);\n\n  writeUInt32BE(publicKey, Q.length, 35);\n  publicKey.set(Q, 39);\n\n  return publicKey;\n}\n\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x01, Ber.Integer);\n    // privateKey\n    asnWriter.writeBuffer(priv, Ber.OctetString);\n    // parameters (optional)\n    asnWriter.startSequence(0xA0);\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n    // publicKey (optional)\n    asnWriter.startSequence(0xA1);\n      asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00);\n        // XXX: hack to write a raw buffer without a tag -- yuck\n        asnWriter._ensure(pub.length);\n        asnWriter._buf.set(pub, asnWriter._offset);\n        asnWriter._offset += pub.length;\n        // end hack\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  const tempECDH = createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\n\nconst BaseKey = {\n  sign: (() => {\n    if (typeof sign_ === 'function') {\n      return function sign(data, algo) {\n        const pem = this[SYM_PRIV_PEM];\n        if (pem === null)\n          return new Error('No private key available');\n        if (!algo || typeof algo !== 'string')\n          algo = this[SYM_HASH_ALGO];\n        try {\n          return sign_(algo, data, pem);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function sign(data, algo) {\n      const pem = this[SYM_PRIV_PEM];\n      if (pem === null)\n        return new Error('No private key available');\n      if (!algo || typeof algo !== 'string')\n        algo = this[SYM_HASH_ALGO];\n      const signature = createSign(algo);\n      signature.update(data);\n      try {\n        return signature.sign(pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  verify: (() => {\n    if (typeof verify_ === 'function') {\n      return function verify(data, signature, algo) {\n        const pem = this[SYM_PUB_PEM];\n        if (pem === null)\n          return new Error('No public key available');\n        if (!algo || typeof algo !== 'string')\n          algo = this[SYM_HASH_ALGO];\n        try {\n          return verify_(algo, data, pem, signature);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function verify(data, signature, algo) {\n      const pem = this[SYM_PUB_PEM];\n      if (pem === null)\n        return new Error('No public key available');\n      if (!algo || typeof algo !== 'string')\n        algo = this[SYM_HASH_ALGO];\n      const verifier = createVerify(algo);\n      verifier.update(data);\n      try {\n        return verifier.verify(pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  isPrivateKey: function isPrivateKey() {\n    return (this[SYM_PRIV_PEM] !== null);\n  },\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n  equals: function equals(key) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error)\n      return false;\n    return (\n      this.type === parsed.type\n      && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM]\n      && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM]\n      && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH]\n    );\n  },\n};\n\n\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo,\n                         decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n  OpenSSH_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    let ret;\n    const data = Buffer.from(m[1], 'base64');\n    if (data.length < 31) // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    const magic = data.utf8Slice(0, 15);\n    if (magic !== 'openssh-key-v1\\0')\n      return new Error(`Unsupported OpenSSH key magic: ${magic}`);\n\n    const cipherName = readString(data, 15, true);\n    if (cipherName === undefined)\n      return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1)\n      return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);\n\n    const kdfName = readString(data, data._pos, true);\n    if (kdfName === undefined)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfName !== 'none') {\n      if (cipherName === 'none')\n        return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt')\n        return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);\n      if (!passphrase) {\n        return new Error(\n          'Encrypted private OpenSSH key detected, but no passphrase given'\n        );\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    let encInfo;\n    let cipherKey;\n    let cipherIV;\n    if (cipherName !== 'none')\n      encInfo = CIPHER_INFO[cipherName];\n    const kdfOptions = readString(data, data._pos);\n    if (kdfOptions === undefined)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n        case 'bcrypt':\n          /*\n            string salt\n            uint32 rounds\n          */\n          const salt = readString(kdfOptions, 0);\n          if (salt === undefined || kdfOptions._pos + 4 > kdfOptions.length)\n            return new Error('Malformed OpenSSH private key');\n          const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n          const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n          const r = bcrypt_pbkdf(passphrase,\n                                 passphrase.length,\n                                 salt,\n                                 salt.length,\n                                 gen,\n                                 gen.length,\n                                 rounds);\n          if (r !== 0)\n            return new Error('Failed to generate information to decrypt key');\n          cipherKey = bufferSlice(gen, 0, encInfo.keyLen);\n          cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);\n          break;\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    if (data._pos + 3 >= data.length)\n      return new Error('Malformed OpenSSH private key');\n    const keyCount = readUInt32BE(data, data._pos);\n    data._pos += 4;\n\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n\n      // Read public keys first\n      for (let i = 0; i < keyCount; ++i) {\n        const pubData = readString(data, data._pos);\n        if (pubData === undefined)\n          return new Error('Malformed OpenSSH private key');\n        const type = readString(pubData, 0, true);\n        if (type === undefined)\n          return new Error('Malformed OpenSSH private key');\n      }\n\n      let privBlob = readString(data, data._pos);\n      if (privBlob === undefined)\n        return new Error('Malformed OpenSSH private key');\n\n      if (cipherKey !== undefined) {\n        // Encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen\n            || (privBlob.length % encInfo.blockLen) !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n        try {\n          const options = { authTagLength: encInfo.authLen };\n          const decipher = createDecipheriv(encInfo.sslName,\n                                            cipherKey,\n                                            cipherIV,\n                                            options);\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen)\n              return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(\n              bufferSlice(data, data._pos, data._pos += encInfo.authLen)\n            );\n          }\n          privBlob = combineBuffers(decipher.update(privBlob),\n                                    decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      }\n      // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n      if (data._pos !== data.length)\n        return new Error('Malformed OpenSSH private key');\n\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n    if (ret instanceof Error)\n      return ret;\n    // This will need to change if/when OpenSSH ever starts storing multiple\n    // keys in their key files\n    return ret[0];\n  };\n\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    const keys = [];\n    /*\n      uint32  checkint\n      uint32  checkint\n      string  privatekey1\n      string  comment1\n      string  privatekey2\n      string  comment2\n      ...\n      string  privatekeyN\n      string  commentN\n      char  1\n      char  2\n      char  3\n      ...\n      char  padlen % 255\n    */\n    if (data.length < 8)\n      return new Error('Malformed OpenSSH private key');\n    const check1 = readUInt32BE(data, 0);\n    const check2 = readUInt32BE(data, 4);\n    if (check1 !== check2) {\n      if (decrypted) {\n        return new Error(\n          'OpenSSH key integrity check failed -- bad passphrase?'\n        );\n      }\n      return new Error('OpenSSH key integrity check failed');\n    }\n    data._pos = 8;\n    let i;\n    let oid;\n    for (i = 0; i < nkeys; ++i) {\n      let algo;\n      let privPEM;\n      let pubPEM;\n      let pubSSH;\n      // The OpenSSH documentation for the key format actually lies, the\n      // entirety of the private key content is not contained with a string\n      // field, it's actually the literal contents of the private key, so to be\n      // able to find the end of the key data you need to know the layout/format\n      // of each key type ...\n      const type = readString(data, data._pos, true);\n      if (type === undefined)\n        return new Error('Malformed OpenSSH private key');\n\n      switch (type) {\n        case 'ssh-rsa': {\n          /*\n            string  n -- public\n            string  e -- public\n            string  d -- private\n            string  iqmp -- private\n            string  p -- private\n            string  q -- private\n          */\n          const n = readString(data, data._pos);\n          if (n === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const e = readString(data, data._pos);\n          if (e === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const d = readString(data, data._pos);\n          if (d === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const iqmp = readString(data, data._pos);\n          if (iqmp === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const p = readString(data, data._pos);\n          if (p === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const q = readString(data, data._pos);\n          if (q === undefined)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          algo = 'sha1';\n          break;\n        }\n        case 'ssh-dss': {\n          /*\n            string  p -- public\n            string  q -- public\n            string  g -- public\n            string  y -- public\n            string  x -- private\n          */\n          const p = readString(data, data._pos);\n          if (p === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const q = readString(data, data._pos);\n          if (q === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const g = readString(data, data._pos);\n          if (g === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const y = readString(data, data._pos);\n          if (y === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const x = readString(data, data._pos);\n          if (x === undefined)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          algo = 'sha1';\n          break;\n        }\n        case 'ssh-ed25519': {\n          if (!eddsaSupported)\n            return new Error(`Unsupported OpenSSH private key type: ${type}`);\n          /*\n            * string  public key\n            * string  private key + public key\n          */\n          const edpub = readString(data, data._pos);\n          if (edpub === undefined || edpub.length !== 32)\n            return new Error('Malformed OpenSSH private key');\n          const edpriv = readString(data, data._pos);\n          if (edpriv === undefined || edpriv.length !== 64)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLEdPub(edpub);\n          pubSSH = genOpenSSHEdPub(edpub);\n          privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));\n          algo = null;\n          break;\n        }\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp521': {\n          if (algo === undefined) {\n            algo = 'sha512';\n            oid = '1.3.132.0.35';\n          }\n          /*\n            string  curve name\n            string  Q -- public\n            string  d -- private\n          */\n          // TODO: validate curve name against type\n          if (!skipFields(data, 1)) // Skip curve name\n            return new Error('Malformed OpenSSH private key');\n          const ecpub = readString(data, data._pos);\n          if (ecpub === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const ecpriv = readString(data, data._pos);\n          if (ecpriv === undefined)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n          pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n          privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n          break;\n        }\n        default:\n          return new Error(`Unsupported OpenSSH private key type: ${type}`);\n      }\n\n      const privComment = readString(data, data._pos, true);\n      if (privComment === undefined)\n        return new Error('Malformed OpenSSH private key');\n\n      keys.push(\n        new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo,\n                            decrypted)\n      );\n    }\n    let cnt = 0;\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== (++cnt % 255))\n        return new Error('Malformed OpenSSH private key');\n    }\n\n    return keys;\n  }\n}\n\n\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo,\n                             decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Old_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n  OpenSSH_Old_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    let privBlob = Buffer.from(m[3], 'base64');\n    let headers = m[2];\n    let decrypted = false;\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n      for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        let sepIdx = header.indexOf(':');\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          const val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1)\n            continue;\n          const cipherName = val.slice(0, sepIdx).toLowerCase();\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(\n              `Cipher (${cipherName}) not supported `\n                + 'for encrypted OpenSSH private key'\n            );\n          }\n          const encInfo = CIPHER_INFO_OPENSSL[cipherName];\n          if (!encInfo) {\n            return new Error(\n              `Cipher (${cipherName}) not supported `\n                + 'for encrypted OpenSSH private key'\n            );\n          }\n          const cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen)\n            return new Error('Malformed encrypted OpenSSH private key');\n          if (!passphrase) {\n            return new Error(\n              'Encrypted OpenSSH private key detected, but no passphrase given'\n            );\n          }\n          const ivSlice = bufferSlice(cipherIV, 0, 8);\n          let cipherKey = createHash('md5')\n                            .update(passphrase)\n                            .update(ivSlice)\n                            .digest();\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(\n              cipherKey,\n              createHash('md5')\n                .update(cipherKey)\n                .update(passphrase)\n                .update(ivSlice)\n                .digest()\n            );\n          }\n          if (cipherKey.length > encInfo.keyLen)\n            cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n          try {\n            const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob),\n                                      decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n\n    let type;\n    let privPEM;\n    let pubPEM;\n    let pubSSH;\n    let algo;\n    let reader;\n    let errMsg = 'Malformed OpenSSH private key';\n    if (decrypted)\n      errMsg += '. Bad passphrase?';\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const n = reader.readString(Ber.Integer, true);\n          if (n === null)\n            return new Error(errMsg);\n          const e = reader.readString(Ber.Integer, true);\n          if (e === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const p = reader.readString(Ber.Integer, true);\n          if (p === null)\n            return new Error(errMsg);\n          const q = reader.readString(Ber.Integer, true);\n          if (q === null)\n            return new Error(errMsg);\n          const g = reader.readString(Ber.Integer, true);\n          if (g === null)\n            return new Error(errMsg);\n          const y = reader.readString(Ber.Integer, true);\n          if (y === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'EC':\n        let ecSSLName;\n        let ecPriv;\n        let ecOID;\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          ecPriv = reader.readString(Ber.OctetString, true);\n          reader.readByte(); // Skip \"complex\" context type byte\n          const offset = reader.readLength(); // Skip context length\n          if (offset !== null) {\n            reader._offset = offset;\n            ecOID = reader.readOID();\n            if (ecOID === null)\n              return new Error(errMsg);\n            switch (ecOID) {\n              case '1.2.840.10045.3.1.7':\n                // prime256v1/secp256r1\n                ecSSLName = 'prime256v1';\n                type = 'ecdsa-sha2-nistp256';\n                algo = 'sha256';\n                break;\n              case '1.3.132.0.34':\n                // secp384r1\n                ecSSLName = 'secp384r1';\n                type = 'ecdsa-sha2-nistp384';\n                algo = 'sha384';\n                break;\n              case '1.3.132.0.35':\n                // secp521r1\n                ecSSLName = 'secp521r1';\n                type = 'ecdsa-sha2-nistp521';\n                algo = 'sha512';\n                break;\n              default:\n                return new Error(`Unsupported private key EC OID: ${ecOID}`);\n            }\n          } else {\n            return new Error(errMsg);\n          }\n        } catch {\n          return new Error(errMsg);\n        }\n        privPEM = makePEM('EC PRIVATE', privBlob);\n        const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n        pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);\n        pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);\n        break;\n    }\n\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo,\n                                   decrypted);\n  };\n}\n\n\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nPPK_Private.prototype = BaseKey;\n{\n  const EMPTY_PASSPHRASE = Buffer.alloc(0);\n  const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  const PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  const PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n  PPK_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n    const cipherName = m[2];\n    const encrypted = (cipherName !== 'none');\n    if (encrypted && !passphrase) {\n      return new Error(\n        'Encrypted PPK private key detected, but no passphrase given'\n      );\n    }\n\n    let privBlob = Buffer.from(m[5], 'base64');\n\n    if (encrypted) {\n      const encInfo = CIPHER_INFO[cipherName];\n      let cipherKey = combineBuffers(\n        createHash('sha1').update(PPK_PP1).update(passphrase).digest(),\n        createHash('sha1').update(PPK_PP2).update(passphrase).digest()\n      );\n      if (cipherKey.length > encInfo.keyLen)\n        cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n      try {\n        const decipher = createDecipheriv(encInfo.sslName,\n                                        cipherKey,\n                                        PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob),\n                                  decipher.final());\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    const type = m[1];\n    const comment = m[3];\n    const pubBlob = Buffer.from(m[4], 'base64');\n\n    const mac = m[6];\n    const typeLen = type.length;\n    const cipherNameLen = cipherName.length;\n    const commentLen = Buffer.byteLength(comment);\n    const pubLen = pubBlob.length;\n    const privLen = privBlob.length;\n    const macData = Buffer.allocUnsafe(4 + typeLen\n                                       + 4 + cipherNameLen\n                                       + 4 + commentLen\n                                       + 4 + pubLen\n                                       + 4 + privLen);\n    let p = 0;\n\n    writeUInt32BE(macData, typeLen, p);\n    macData.utf8Write(type, p += 4, typeLen);\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.utf8Write(cipherName, p += 4, cipherNameLen);\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.utf8Write(comment, p += 4, commentLen);\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    macData.set(pubBlob, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    macData.set(privBlob, p + 4);\n\n    if (!passphrase)\n      passphrase = EMPTY_PASSPHRASE;\n\n    const calcMAC = createHmac(\n      'sha1',\n       createHash('sha1')\n         .update('putty-private-key-file-mac-key')\n         .update(passphrase)\n         .digest()\n    ).update(macData).digest('hex');\n\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error(\n          'PPK private key integrity check failed -- bad passphrase?'\n        );\n      }\n      return new Error('PPK private key integrity check failed');\n    }\n\n    let pubPEM;\n    let pubSSH;\n    let privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n    switch (type) {\n      case 'ssh-rsa': {\n        const e = readString(pubBlob, pubBlob._pos);\n        if (e === undefined)\n          return new Error('Malformed PPK public key');\n        const n = readString(pubBlob, pubBlob._pos);\n        if (n === undefined)\n          return new Error('Malformed PPK public key');\n        const d = readString(privBlob, 0);\n        if (d === undefined)\n          return new Error('Malformed PPK private key');\n        const p = readString(privBlob, privBlob._pos);\n        if (p === undefined)\n          return new Error('Malformed PPK private key');\n        const q = readString(privBlob, privBlob._pos);\n        if (q === undefined)\n          return new Error('Malformed PPK private key');\n        const iqmp = readString(privBlob, privBlob._pos);\n        if (iqmp === undefined)\n          return new Error('Malformed PPK private key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n        break;\n      }\n      case 'ssh-dss': {\n        const p = readString(pubBlob, pubBlob._pos);\n        if (p === undefined)\n          return new Error('Malformed PPK public key');\n        const q = readString(pubBlob, pubBlob._pos);\n        if (q === undefined)\n          return new Error('Malformed PPK public key');\n        const g = readString(pubBlob, pubBlob._pos);\n        if (g === undefined)\n          return new Error('Malformed PPK public key');\n        const y = readString(pubBlob, pubBlob._pos);\n        if (y === undefined)\n          return new Error('Malformed PPK public key');\n        const x = readString(privBlob, 0);\n        if (x === undefined)\n          return new Error('Malformed PPK private key');\n\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n        break;\n      }\n    }\n\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1',\n                           encrypted);\n  };\n}\n\n\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nOpenSSH_Public.prototype = BaseKey;\n{\n  let regexp;\n  if (eddsaSupported)\n    regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  else\n    regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  OpenSSH_Public.parse = (str) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    const fullType = m[1];\n    const baseType = m[2];\n    const data = Buffer.from(m[3], 'base64');\n    const comment = (m[4] || '');\n\n    const type = readString(data, data._pos, true);\n    if (type === undefined || type.indexOf(baseType) !== 0)\n      return new Error('Malformed OpenSSH public key');\n\n    return parseDER(data, baseType, comment, fullType);\n  };\n}\n\n\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nRFC4716_Public.prototype = BaseKey;\n{\n  const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r?\\n)((?:.{0,72}\\r?\\n)+)---- END SSH2 PUBLIC KEY ----$/;\n  const RE_DATA = /^[A-Z0-9a-z/+=\\r\\n]+$/;\n  const RE_HEADER = /^([\\x21-\\x39\\x3B-\\x7E]{1,64}): ((?:[^\\\\]*\\\\\\r?\\n)*[^\\r\\n]+)\\r?\\n/gm;\n  const RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n  RFC4716_Public.parse = (str) => {\n    let m = regexp.exec(str);\n    if (m === null)\n      return null;\n\n    const body = m[1];\n    let dataStart = 0;\n    let comment = '';\n\n    while (m = RE_HEADER.exec(body)) {\n      const headerName = m[1];\n      const headerValue = m[2].replace(RE_HEADER_ENDS, '');\n      if (headerValue.length > 1024) {\n        RE_HEADER.lastIndex = 0;\n        return new Error('Malformed RFC4716 public key');\n      }\n\n      dataStart = RE_HEADER.lastIndex;\n\n      if (headerName.toLowerCase() === 'comment') {\n        comment = headerValue;\n        if (comment.length > 1\n            && comment.charCodeAt(0) === 34/* '\"' */\n            && comment.charCodeAt(comment.length - 1) === 34/* '\"' */) {\n          comment = comment.slice(1, -1);\n        }\n      }\n    }\n\n    let data = body.slice(dataStart);\n    if (!RE_DATA.test(data))\n      return new Error('Malformed RFC4716 public key');\n\n    data = Buffer.from(data, 'base64');\n\n    const type = readString(data, 0, true);\n    if (type === undefined)\n      return new Error('Malformed RFC4716 public key');\n\n    let pubPEM = null;\n    let pubSSH = null;\n    switch (type) {\n      case 'ssh-rsa': {\n        const e = readString(data, data._pos);\n        if (e === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const n = readString(data, data._pos);\n        if (n === undefined)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        break;\n      }\n      case 'ssh-dss': {\n        const p = readString(data, data._pos);\n        if (p === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const q = readString(data, data._pos);\n        if (q === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const g = readString(data, data._pos);\n        if (g === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const y = readString(data, data._pos);\n        if (y === undefined)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        break;\n      }\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n}\n\n\nfunction parseDER(data, baseType, comment, fullType) {\n  if (!isSupportedKeyType(baseType))\n    return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n\n  let algo;\n  let oid;\n  let pubPEM = null;\n  let pubSSH = null;\n\n  switch (baseType) {\n    case 'ssh-rsa': {\n      const e = readString(data, data._pos || 0);\n      if (e === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const n = readString(data, data._pos);\n      if (n === undefined)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLRSAPub(n, e);\n      pubSSH = genOpenSSHRSAPub(n, e);\n      algo = 'sha1';\n      break;\n    }\n    case 'ssh-dss': {\n      const p = readString(data, data._pos || 0);\n      if (p === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const q = readString(data, data._pos);\n      if (q === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const g = readString(data, data._pos);\n      if (g === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const y = readString(data, data._pos);\n      if (y === undefined)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLDSAPub(p, q, g, y);\n      pubSSH = genOpenSSHDSAPub(p, q, g, y);\n      algo = 'sha1';\n      break;\n    }\n    case 'ssh-ed25519': {\n      const edpub = readString(data, data._pos || 0);\n      if (edpub === undefined || edpub.length !== 32)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLEdPub(edpub);\n      pubSSH = genOpenSSHEdPub(edpub);\n      algo = null;\n      break;\n    }\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp521': {\n      if (algo === undefined) {\n        algo = 'sha512';\n        oid = '1.3.132.0.35';\n      }\n      // TODO: validate curve name against type\n      if (!skipFields(data, 1)) // Skip curve name\n        return new Error('Malformed OpenSSH public key');\n      const ecpub = readString(data, data._pos || 0);\n      if (ecpub === undefined)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n      pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n      break;\n    }\n    default:\n      return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  }\n\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\n\nfunction isSupportedKeyType(type) {\n  switch (type) {\n    case 'ssh-rsa':\n    case 'ssh-dss':\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return true;\n    case 'ssh-ed25519':\n      if (eddsaSupported)\n        return true;\n    // FALLTHROUGH\n    default:\n      return false;\n  }\n}\n\nfunction isParsedKey(val) {\n  if (!val)\n    return false;\n  return (typeof val[SYM_DECRYPTED] === 'boolean');\n}\n\nfunction parseKey(data, passphrase) {\n  if (isParsedKey(data))\n    return data;\n\n  let origBuffer;\n  if (Buffer.isBuffer(data)) {\n    origBuffer = data;\n    data = data.utf8Slice(0, data.length).trim();\n  } else if (typeof data === 'string') {\n    data = data.trim();\n  } else {\n    return new Error('Key data must be a Buffer or string');\n  }\n\n  // eslint-disable-next-line eqeqeq\n  if (passphrase != undefined) {\n    if (typeof passphrase === 'string')\n      passphrase = Buffer.from(passphrase);\n    else if (!Buffer.isBuffer(passphrase))\n      return new Error('Passphrase must be a string or Buffer when supplied');\n  }\n\n  let ret;\n\n  // First try as printable string format (e.g. PEM)\n\n  // Private keys\n  if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)\n    return ret;\n  if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)\n    return ret;\n  if ((ret = PPK_Private.parse(data, passphrase)) !== null)\n    return ret;\n\n  // Public keys\n  if ((ret = OpenSSH_Public.parse(data)) !== null)\n    return ret;\n  if ((ret = RFC4716_Public.parse(data)) !== null)\n    return ret;\n\n  // Finally try as a binary format if we were originally passed binary data\n  if (origBuffer) {\n    binaryKeyParser.init(origBuffer, 0);\n    const type = binaryKeyParser.readString(true);\n    if (type !== undefined) {\n      data = binaryKeyParser.readRaw();\n      if (data !== undefined) {\n        ret = parseDER(data, type, '', type);\n        // Ignore potentially useless errors in case the data was not actually\n        // in the binary format\n        if (ret instanceof Error)\n          ret = null;\n      }\n    }\n    binaryKeyParser.clear();\n  }\n\n  if (ret)\n    return ret;\n\n  return new Error('Unsupported key format');\n}\n\nmodule.exports = {\n  isParsedKey,\n  isSupportedKeyType,\n  parseDERKey: (data, type) => parseDER(data, type, '', type),\n  parseKey,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync\n} = require('crypto');\nconst {\n  Socket\n} = require('net');\nconst {\n  lookup: dnsLookup\n} = require('dns');\nconst EventEmitter = require('events');\nconst HASHES = getHashes();\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: {\n    STDERR\n  },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./protocol/utils.js');\nconst {\n  AgentContext,\n  createAgent,\n  isAgent\n} = require('./agent.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nconst noop = err => {};\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n  connect(cfg) {\n    var _this = this;\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = typeof cfg.localAddress === 'string' ? cfg.localAddress : undefined;\n    this.config.localPort = typeof cfg.localPort === 'string' || typeof cfg.localPort === 'number' ? cfg.localPort : undefined;\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === 'number' && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;\n    this.config.keepaliveInterval = typeof cfg.keepaliveInterval === 'number' && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;\n    this.config.readyTimeout = typeof cfg.readyTimeout === 'number' && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 20000;\n    this.config.ident = typeof cfg.ident === 'string' || Buffer.isBuffer(cfg.ident) ? cfg.ident : undefined;\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: []\n      },\n      sc: undefined\n    };\n    let allOfferDefaults = true;\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex, DEFAULT_KEX, SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX) allOfferDefaults = false;\n      algorithms.serverHostKey = generateAlgorithmList(cfg.algorithms.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY) allOfferDefaults = false;\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER) allOfferDefaults = false;\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac, DEFAULT_MAC, SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC) allOfferDefaults = false;\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION) allOfferDefaults = false;\n      if (!allOfferDefaults) algorithms.sc = algorithms.cs;\n    }\n    if (typeof cfg.username === 'string') this.config.username = cfg.username;else if (typeof cfg.user === 'string') this.config.username = cfg.user;else throw new Error('Invalid username');\n    this.config.password = typeof cfg.password === 'string' ? cfg.password : undefined;\n    this.config.privateKey = typeof cfg.privateKey === 'string' || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : undefined;\n    this.config.localHostname = typeof cfg.localHostname === 'string' ? cfg.localHostname : undefined;\n    this.config.localUsername = typeof cfg.localUsername === 'string' ? cfg.localUsername : undefined;\n    this.config.tryKeyboard = cfg.tryKeyboard === true;\n    if (typeof cfg.agent === 'string' && cfg.agent.length) this.config.agent = createAgent(cfg.agent);else if (isAgent(cfg.agent)) this.config.agent = cfg.agent;else this.config.agent = undefined;\n    this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== undefined;\n    let authHandler = this.config.authHandler = typeof cfg.authHandler === 'function' || Array.isArray(cfg.authHandler) ? cfg.authHandler : undefined;\n    this.config.strictVendor = typeof cfg.strictVendor === 'boolean' ? cfg.strictVendor : true;\n    const debug = this.config.debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error('You must set a valid agent path to allow agent forwarding');\n    }\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = this.config.agent ? this.config.agent : undefined;\n    this._remoteVer = undefined;\n    let privateKey;\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error('privateKey value does not contain a (valid) private key');\n      }\n    }\n    let hostVerifier;\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hasher;\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hasher = createHash(cfg.hostHash);\n      }\n      hostVerifier = (key, verify) => {\n        if (hasher) {\n          hasher.update(key);\n          key = hasher.digest('hex');\n        }\n        const ret = hashCb(key, verify);\n        if (ret !== undefined) verify(ret);\n      };\n    }\n    const sock = this._sock = cfg.sock || new Socket();\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol) this._protocol.cleanup();\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    };\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: allOfferDefaults ? undefined : algorithms,\n      onWrite: data => {\n        if (isWritable(sock)) sock.write(data);\n      },\n      onError: err => {\n        if (err.level === 'handshake') clearTimeout(this._readyTimeout);\n        if (!proto._destruct) sock.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: header => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        this.emit('handshake', negotiated);\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth') tryNextAuth();\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: p => {\n          // Start keepalive mechanism\n          resetKA();\n          clearTimeout(this._readyTimeout);\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, newPassword => {\n              proto.authPassword(this.config.username, this.config.password, newPassword);\n            });\n          }\n        },\n        USERAUTH_PK_OK: p => {\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, (buf, cb) => {\n              curAuth.agentCtx.sign(key, buf, {}, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n              if (signature instanceof Error) {\n                signature.message = `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = Array.isArray(prompts) ? prompts.length : 0;\n            if (nprompts === 0) {\n              debug && debug('Client: Sending automatic USERAUTH_INFO_RESPONSE');\n              proto.authInfoRes();\n              return;\n            }\n            // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n            curAuth.prompt(name, instructions, '', prompts, answers => {\n              proto.authInfoRes(answers);\n            });\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length) callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: p => {\n          if (callbacks.length) callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err) return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply) proto.requestSuccess();\n              break;\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply) proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function') return;\n          const isSFTP = channel.type === 'sftp';\n          const type = isSFTP ? 'session' : channel.type;\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = isSFTP ? new SFTP(this, chanInfo, {\n            debug\n          }) : new Channel(this, chanInfo);\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR) return;\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          this._resetKA();\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          this._resetKA();\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          const exit = channel._exit;\n          if (exit.code !== undefined) return;\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n            case 'exit-signal':\n              channel.emit('exit', exit.code = null, exit.signal = `SIG${data.signal}`, exit.dump = data.coreDumped, exit.desc = data.errorMessage);\n              return;\n          }\n\n          // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n          if (wantReply) p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n          if (channel.stderr.readable) channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        }\n      }\n    });\n    sock.pause();\n\n    // TODO: check keepalive implementation\n    // Keepalive-related\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n        return;\n      }\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock)) katimer = setInterval(sendKA, kainterval);\n      }\n    }\n    this._resetKA = resetKA;\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        if (wasConnected && !sawHeader) {\n          const err = makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', data => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n              try {\n                if (isWritable(sock)) sock.end();\n              } catch {}\n            }\n          });\n\n          // Drain stderr if we are connection hopping using an exec stream\n          if (sock.stderr && typeof sock.stderr.resume === 'function') sock.stderr.resume();\n          sock.resume();\n        }).catch(err => {\n          this.emit('error', err);\n          try {\n            if (isWritable(sock)) sock.end();\n          } catch {}\n        });\n      };\n    })();\n    let wasConnected = false;\n    sock.on('connect', onConnect).on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', err => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close');\n\n      // Notify outstanding channel requests of disconnection ...\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n      for (let i = 0; i < callbacks_.length; ++i) callbacks_[i](err);\n\n      // Simulate error for any channels waiting to be opened\n      this._chanMgr.cleanup(err);\n    });\n\n    // Begin authentication handling ===========================================\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined) authsAllowed.push('password');\n    if (privateKey !== undefined) authsAllowed.push('publickey');\n    if (this._agent !== undefined) authsAllowed.push('agent');\n    if (this.config.tryKeyboard) authsAllowed.push('keyboard-interactive');\n    if (privateKey !== undefined && this.config.localHostname !== undefined && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n    if (Array.isArray(authHandler)) authHandler = makeSimpleAuthHandler(authHandler);else if (typeof authHandler !== 'function') authHandler = makeSimpleAuthHandler(authsAllowed);\n    let hasSentAuth = false;\n    const doNextAuth = nextAuth => {\n      if (hasSentAuth) return;\n      hasSentAuth = true;\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1) return skipAuth(`Authentication method not allowed: ${type}`);\n        const username = this.config.username;\n        switch (type) {\n          case 'password':\n            nextAuth = {\n              type,\n              username,\n              password: this.config.password\n            };\n            break;\n          case 'publickey':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey\n            };\n            break;\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername\n            };\n            break;\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent)\n            };\n            break;\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                return _this.emit('keyboard-interactive', ...args);\n              }\n            };\n            break;\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n      } else {\n        const username = nextAuth.username;\n        if (typeof username !== 'string') {\n          return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n        }\n        const type = nextAuth.type;\n        switch (type) {\n          case 'password':\n            {\n              const {\n                password\n              } = nextAuth;\n              if (typeof password !== 'string' && !Buffer.isBuffer(password)) return skipAuth('Skipping invalid password auth attempt');\n              nextAuth = {\n                type,\n                username,\n                password\n              };\n              break;\n            }\n          case 'publickey':\n            {\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error) return skipAuth('Skipping invalid key auth attempt');\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key\n              };\n              break;\n            }\n          case 'hostbased':\n            {\n              const {\n                localHostname,\n                localUsername\n              } = nextAuth;\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error || typeof localHostname !== 'string' || typeof localUsername !== 'string') {\n                return skipAuth('Skipping invalid hostbased auth attempt');\n              }\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key,\n                localHostname,\n                localUsername\n              };\n              break;\n            }\n          case 'agent':\n            {\n              let agent = nextAuth.agent;\n              if (typeof agent === 'string' && agent.length) {\n                agent = createAgent(agent);\n              } else if (!isAgent(agent)) {\n                return skipAuth(`Skipping invalid agent: ${nextAuth.agent}`);\n              }\n              nextAuth = {\n                type,\n                username,\n                agentCtx: new AgentContext(agent)\n              };\n              break;\n            }\n          case 'keyboard-interactive':\n            {\n              const {\n                prompt\n              } = nextAuth;\n              if (typeof prompt !== 'function') {\n                return skipAuth('Skipping invalid keyboard-interactive auth attempt');\n              }\n              nextAuth = {\n                type,\n                username,\n                prompt\n              };\n              break;\n            }\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      }\n      curAuth = nextAuth;\n\n      // Begin authentication method's process\n      try {\n        const username = curAuth.username;\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n          case 'publickey':\n            proto.authPK(username, curAuth.key);\n            break;\n          case 'hostbased':\n            proto.authHostbased(username, curAuth.key, curAuth.localHostname, curAuth.localUsername, (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n              if (signature instanceof Error) {\n                signature.message = `Error while signing with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n            break;\n          case 'agent':\n            curAuth.agentCtx.init(err => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n              tryNextAgentKey();\n            });\n            break;\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined) return;\n      doNextAuth(auth);\n    }\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key);\n        }\n      }\n    };\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setNoDelay(true);\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n      if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {\n        doConnect();\n      } else {\n        dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {\n          if (err) {\n            const type = forceIPv4 ? 'IPv4' : 'IPv6';\n            const error = new Error(`Error while looking up ${type} address for '${host}': ${err}`);\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n    return this;\n  }\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    const extraOpts = {\n      allowHalfOpen: opts.allowHalfOpen !== false\n    };\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const todo = [];\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length) todo.shift()();\n      }\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n        if (typeof opts.pty === 'object' && opts.pty !== null || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const todo = [];\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length) todo.shift()();\n      }\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n      if (wndopts !== false) todo.push(() => reqPty(chan, wndopts, reqCb));\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        cb(undefined, stream);\n      });\n    });\n    return this;\n  }\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = typeof cb === 'function';\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n        let realPort = bindPort;\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG)) bindPort = realPort;\n        }\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n        cb(undefined, realPort);\n      });\n    }\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n    return this;\n  }\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = typeof cb === 'function';\n    if (wantReply) {\n      this._callbacks.push(had_err => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n        cb();\n      });\n    }\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n    return this;\n  }\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n    if (typeof cb !== 'function') cb = noop;\n    openChannel(this, 'direct-tcpip', cfg, cb);\n    return this;\n  }\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error('Unable to disable future sessions'));\n            return;\n          }\n          cb();\n        });\n      }\n      this._protocol.openssh_noMoreSessions(wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof cb !== 'function') cb = noop;\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      openChannel(this, 'direct-streamlocal@openssh.com', {\n        socketPath\n      }, cb);\n      return this;\n    }\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number') msg = `Received exit code ${code} while establishing SFTP session`;else if (signal !== undefined) msg = `Received signal ${signal} while establishing SFTP session`;else msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n        sftp.on('ready', onReady).on('error', onError).on('exit', onExit).on('close', onExit);\n        sftp._init();\n      });\n    });\n    return this;\n  }\n}\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n  const localChan = self._chanMgr.add(wrapper);\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n      break;\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(localChan, initWindow, maxPacket, opts);\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean') cfg.single = screen.single;\n    if (typeof screen.screen === 'number') cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string') cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string') cfg.cookie = screen.cookie;else if (Buffer.isBuffer(screen.cookie)) cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n  if (cfg.cookie === undefined) cfg.cookie = randomCookie();\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11) --chan._client._acceptX11;\n      });\n      cb();\n    });\n  }\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number') rows = opts.rows;\n    if (typeof opts.cols === 'number') cols = opts.cols;\n    if (typeof opts.width === 'number') width = opts.width;\n    if (typeof opts.height === 'number') height = opts.height;\n    if (typeof opts.term === 'string') term = opts.term;\n    if (typeof opts.modes === 'object') modes = opts.modes;\n  }\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n      cb();\n    });\n  }\n  chan._client._protocol.pty(chan.outgoing.id, rows, cols, height, width, term, modes, wantReply);\n}\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n  chan._client._agentFwdEnabled = true;\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      if (wantReply) {\n        cb(had_err !== true ? had_err : new Error('Unable to request agent forwarding'));\n      }\n      return;\n    }\n    if (wantReply) cb();\n  });\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = opts.allowHalfOpen !== false;\n    cb(undefined, chan);\n  });\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open') return;\n  const keys = Object.keys(env || {});\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n}\n\n// TODO: inline implementation into single call site\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  let localChan = -1;\n  let reason;\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n    self._chanMgr.update(localChan, stream);\n    self._protocol.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n    return stream;\n  };\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n    if (localChan !== -1) self._chanMgr.remove(localChan);\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of incoming channel open: ' + 'no channels available');\n      }\n    }\n    return localChan !== -1;\n  };\n  const data = info.data;\n  switch (info.type) {\n    case 'forwarded-tcpip':\n      {\n        const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n        if (val !== undefined && reserveChannel()) {\n          if (data.destPort === 0) data.destPort = val;\n          self.emit('tcp connection', data, accept, reject);\n          return;\n        }\n        break;\n      }\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n      break;\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled && typeof self._agent.getStream === 'function' && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err) return reject();\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n        return;\n      }\n      break;\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n      break;\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of unsupported incoming channel open ' + `type: ${info.type}`);\n      }\n  }\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n    if (self.config.debug) {\n      self.config.debug('Client: Automatic rejection of unexpected incoming channel open for: ' + info.type);\n    }\n  }\n  reject();\n}\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList)) throw new Error('authList must be an array');\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length) return false;\n    return authList[a++];\n  };\n}\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock)) return;\n  if (typeof cb !== 'function') cb = noop;\n  if (!Array.isArray(keys_)) throw new TypeError('Invalid keys argument type');\n  const keys = [];\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) throw parsed;\n    keys.push(parsed);\n  }\n  if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Server failed to prove supplied keys'));\n        return;\n      }\n\n      // TODO: move all of this parsing/verifying logic out of the client?\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length) break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n        let algo;\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(4 + 29 + 4 + sessionID.length + 4 + keyPublic.length);\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n        if (!(value = sigSSHToASN1(value, type))) continue;\n        if (key.verify(verifyData, value, algo) === true) ret.push(key);\n      }\n      sigParser.clear();\n      bufferParser.clear();\n      cb(null, ret);\n    });\n    client._protocol.openssh_hostKeysProve(keys);\n    return;\n  }\n  process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n}\nmodule.exports = Client;","map":{"version":3,"names":["createHash","getHashes","randomFillSync","require","Socket","lookup","dnsLookup","EventEmitter","HASHES","COMPAT","CHANNEL_EXTENDED_DATATYPE","STDERR","CHANNEL_OPEN_FAILURE","DEFAULT_CIPHER","DEFAULT_COMPRESSION","DEFAULT_KEX","DEFAULT_MAC","DEFAULT_SERVER_HOST_KEY","DISCONNECT_REASON","DISCONNECT_REASON_BY_VALUE","SUPPORTED_CIPHER","SUPPORTED_COMPRESSION","SUPPORTED_KEX","SUPPORTED_MAC","SUPPORTED_SERVER_HOST_KEY","init","cryptoInit","Protocol","parseKey","SFTP","bufferCopy","makeBufferParser","makeError","readUInt32BE","sigSSHToASN1","writeUInt32BE","AgentContext","createAgent","isAgent","Channel","MAX_WINDOW","PACKET_SIZE","windowAdjust","WINDOW_THRESHOLD","ChannelManager","generateAlgorithmList","isWritable","onChannelOpenFailure","onCHANNEL_CLOSE","bufferParser","sigParser","RE_OPENSSH","noop","err","Client","constructor","config","host","undefined","port","localAddress","localPort","forceIPv4","forceIPv6","keepaliveCountMax","keepaliveInterval","readyTimeout","ident","username","password","privateKey","tryKeyboard","agent","allowAgentFwd","authHandler","hostHashAlgo","hostHashCb","strictVendor","debug","_agent","_readyTimeout","_chanMgr","_callbacks","_forwarding","_forwardingUnix","_acceptX11","_agentFwdEnabled","_remoteVer","_protocol","_sock","_resetKA","connect","cfg","_this","once","end","hostname","Buffer","isBuffer","algorithms","kex","serverHostKey","cs","cipher","mac","compress","lang","sc","allOfferDefaults","hmac","user","Error","localHostname","localUsername","length","agentForward","Array","isArray","callbacks","passphrase","message","getPrivatePEM","hostVerifier","hashCb","hasher","indexOf","hostHash","key","verify","update","digest","ret","sock","ready","sawHeader","cleanup","DEBUG_HANDLER","p","display","msg","JSON","stringify","proto","offer","onWrite","data","write","onError","level","clearTimeout","_destruct","removeAllListeners","emit","onHeader","header","versions","software","greeting","onHandshakeComplete","negotiated","service","messageHandlers","DEBUG","DISCONNECT","reason","desc","BY_APPLICATION","code","SERVICE_ACCEPT","name","tryNextAuth","USERAUTH_BANNER","USERAUTH_SUCCESS","resetKA","USERAUTH_FAILURE","authMethods","partialSuccess","curAuth","type","pos","agentCtx","tryNextAgentKey","curPartial","curAuthsLeft","USERAUTH_PASSWD_CHANGEREQ","prompt","newPassword","authPassword","USERAUTH_PK_OK","currentKey","authPK","buf","cb","sign","signed","signature","USERAUTH_INFO_REQUEST","instructions","prompts","nprompts","authInfoRes","answers","REQUEST_SUCCESS","shift","REQUEST_FAILURE","GLOBAL_REQUEST","wantReply","hostKeysProve","keys","requestSuccess","requestFailure","CHANNEL_OPEN","info","onCHANNEL_OPEN","CHANNEL_OPEN_CONFIRMATION","channel","get","recipient","isSFTP","chanInfo","incoming","id","window","packetSize","state","outgoing","sender","instance","description","CHANNEL_DATA","push","_waitChanDrain","CHANNEL_EXTENDED_DATA","stderr","CHANNEL_WINDOW_ADJUST","amount","_waitWindow","_chunk","_write","_chunkcb","_chunkErr","_chunkcbErr","CHANNEL_SUCCESS","CHANNEL_FAILURE","CHANNEL_REQUEST","exit","_exit","signal","dump","coreDumped","errorMessage","channelFailure","CHANNEL_EOF","readable","CHANNEL_CLOSE","pause","kainterval","kacountmax","kacount","katimer","sendKA","clearInterval","destroy","ping","setInterval","onDone","called","wasConnected","onConnect","then","start","on","parse","ex","resume","catch","callbacks_","i","authsAllowed","makeSimpleAuthHandler","hasSentAuth","doNextAuth","nextAuth","skipAuth","_len","arguments","args","_key","isPrivateKey","authHostbased","authKeyboard","authNone","process","nextTick","auth","nextKey","startTimeout","setTimeout","doConnect","setNoDelay","setMaxListeners","timeout","address","family","error","connecting","disconnect","exec","cmd","opts","extraOpts","allowHalfOpen","openChannel","chan","todo","reqCb","close","reqAgentFwd","env","reqEnv","pty","reqPty","x11","reqX11","reqExec","shell","wndopts","reqShell","subsys","reqSubsystem","stream","forwardIn","bindAddr","bindPort","had_err","realPort","_compatFlags","DYN_RPORT_BUG","tcpipForward","unforwardIn","cancelTcpipForward","forwardOut","srcIP","srcPort","dstIP","dstPort","openssh_noMoreSessions","test","openssh_forwardInStreamLocal","socketPath","openssh_streamLocalForward","openssh_unforwardInStreamLocal","openssh_cancelStreamLocalForward","openssh_forwardOutStreamLocal","sftp","sftp_","removeListeners","removeListener","onReady","onExit","_init","self","initWindow","maxPacket","wrapper","localChan","add","session","directTcpip","openssh_directStreamLocal","screen","single","protocol","cookie","hexSlice","randomCookie","_hasX11","_client","x11Forward","rows","cols","width","height","term","modes","openssh_agentForward","subtype","Object","val","subsystem","accept","channelOpenConfirm","reject","RESOURCE_SHORTAGE","CONNECT_FAILED","remove","channelOpenFail","reserveChannel","destIP","destPort","getStream","upstream","pipe","UNKNOWN_CHANNEL_TYPE","ADMINISTRATIVELY_PROHIBITED","buffer","allocUnsafe","authList","a","authsLeft","client","keys_","TypeError","parsed","keyIdx","avail","keyPublic","getPublicSSH","sigEntry","readString","value","algo","sessionID","_kex","verifyData","utf8Write","clear","openssh_hostKeysProve","module","exports"],"sources":["C:/Users/hummas/Desktop/React/food-ordering-app/node_modules/ssh2/lib/client.js"],"sourcesContent":["// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync,\n} = require('crypto');\nconst { Socket } = require('net');\nconst { lookup: dnsLookup } = require('dns');\nconst EventEmitter = require('events');\nconst HASHES = getHashes();\n\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: { STDERR },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY,\n} = require('./protocol/constants.js');\nconst { init: cryptoInit } = require('./protocol/crypto.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst { parseKey } = require('./protocol/keyParser.js');\nconst { SFTP } = require('./protocol/SFTP.js');\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE,\n} = require('./protocol/utils.js');\n\nconst { AgentContext, createAgent, isAgent } = require('./agent.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD,\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n} = require('./utils.js');\n\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nconst noop = (err) => {};\n\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n\n  connect(cfg) {\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = (typeof cfg.localAddress === 'string'\n                                ? cfg.localAddress\n                                : undefined);\n    this.config.localPort = (typeof cfg.localPort === 'string'\n                             || typeof cfg.localPort === 'number'\n                             ? cfg.localPort\n                             : undefined);\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'\n                                     && cfg.keepaliveCountMax >= 0\n                                     ? cfg.keepaliveCountMax\n                                     : 3);\n    this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'\n                                     && cfg.keepaliveInterval > 0\n                                     ? cfg.keepaliveInterval\n                                     : 0);\n    this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'\n                                && cfg.readyTimeout >= 0\n                                ? cfg.readyTimeout\n                                : 20000);\n    this.config.ident = (typeof cfg.ident === 'string'\n                         || Buffer.isBuffer(cfg.ident)\n                         ? cfg.ident\n                         : undefined);\n\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: [],\n      },\n      sc: undefined,\n    };\n    let allOfferDefaults = true;\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex,\n                                             DEFAULT_KEX,\n                                             SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX)\n        allOfferDefaults = false;\n\n      algorithms.serverHostKey =\n        generateAlgorithmList(cfg.algorithms.serverHostKey,\n                              DEFAULT_SERVER_HOST_KEY,\n                              SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)\n        allOfferDefaults = false;\n\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher,\n                                                   DEFAULT_CIPHER,\n                                                   SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER)\n        allOfferDefaults = false;\n\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac,\n                                                DEFAULT_MAC,\n                                                SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC)\n        allOfferDefaults = false;\n\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress,\n                                                     DEFAULT_COMPRESSION,\n                                                     SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION)\n        allOfferDefaults = false;\n\n      if (!allOfferDefaults)\n        algorithms.sc = algorithms.cs;\n    }\n\n    if (typeof cfg.username === 'string')\n      this.config.username = cfg.username;\n    else if (typeof cfg.user === 'string')\n      this.config.username = cfg.user;\n    else\n      throw new Error('Invalid username');\n\n    this.config.password = (typeof cfg.password === 'string'\n                            ? cfg.password\n                            : undefined);\n    this.config.privateKey = (typeof cfg.privateKey === 'string'\n                              || Buffer.isBuffer(cfg.privateKey)\n                              ? cfg.privateKey\n                              : undefined);\n    this.config.localHostname = (typeof cfg.localHostname === 'string'\n                                 ? cfg.localHostname\n                                 : undefined);\n    this.config.localUsername = (typeof cfg.localUsername === 'string'\n                                 ? cfg.localUsername\n                                 : undefined);\n    this.config.tryKeyboard = (cfg.tryKeyboard === true);\n    if (typeof cfg.agent === 'string' && cfg.agent.length)\n      this.config.agent = createAgent(cfg.agent);\n    else if (isAgent(cfg.agent))\n      this.config.agent = cfg.agent;\n    else\n      this.config.agent = undefined;\n    this.config.allowAgentFwd = (cfg.agentForward === true\n                                 && this.config.agent !== undefined);\n    let authHandler = this.config.authHandler = (\n      typeof cfg.authHandler === 'function'\n      || Array.isArray(cfg.authHandler)\n      ? cfg.authHandler\n      : undefined\n    );\n\n    this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'\n                                ? cfg.strictVendor\n                                : true);\n\n    const debug = this.config.debug = (typeof cfg.debug === 'function'\n                                       ? cfg.debug\n                                       : undefined);\n\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error(\n        'You must set a valid agent path to allow agent forwarding'\n      );\n    }\n\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = (this.config.agent ? this.config.agent : undefined);\n    this._remoteVer = undefined;\n    let privateKey;\n\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error)\n        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error(\n          'privateKey value does not contain a (valid) private key'\n        );\n      }\n    }\n\n    let hostVerifier;\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hasher;\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hasher = createHash(cfg.hostHash);\n      }\n      hostVerifier = (key, verify) => {\n        if (hasher) {\n          hasher.update(key);\n          key = hasher.digest('hex');\n        }\n        const ret = hashCb(key, verify);\n        if (ret !== undefined)\n          verify(ret);\n      };\n    }\n\n    const sock = this._sock = (cfg.sock || new Socket());\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol)\n      this._protocol.cleanup();\n    const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    });\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: (allOfferDefaults ? undefined : algorithms),\n      onWrite: (data) => {\n        if (isWritable(sock))\n          sock.write(data);\n      },\n      onError: (err) => {\n        if (err.level === 'handshake')\n          clearTimeout(this._readyTimeout);\n        if (!proto._destruct)\n          sock.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: (header) => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting)\n          this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: (negotiated) => {\n        this.emit('handshake', negotiated);\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined)\n                desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth')\n            tryNextAuth();\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: (p) => {\n          // Start keepalive mechanism\n          resetKA();\n\n          clearTimeout(this._readyTimeout);\n\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, (newPassword) => {\n              proto.authPassword(\n                this.config.username,\n                this.config.password,\n                newPassword\n              );\n            });\n          }\n        },\n        USERAUTH_PK_OK: (p) => {\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, (buf, cb) => {\n              curAuth.agentCtx.sign(key, buf, {}, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n              if (signature instanceof Error) {\n                signature.message =\n                  `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = (Array.isArray(prompts) ? prompts.length : 0);\n            if (nprompts === 0) {\n              debug && debug(\n                'Client: Sending automatic USERAUTH_INFO_RESPONSE'\n              );\n              proto.authInfoRes();\n              return;\n            }\n            // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n            curAuth.prompt(\n              name,\n              instructions,\n              '',\n              prompts,\n              (answers) => {\n                proto.authInfoRes(answers);\n              }\n            );\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length)\n            callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: (p) => {\n          if (callbacks.length)\n            callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err)\n                  return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply)\n                proto.requestSuccess();\n              break;\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply)\n                proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const isSFTP = (channel.type === 'sftp');\n          const type = (isSFTP ? 'session' : channel.type);\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = (\n            isSFTP\n            ? new SFTP(this, chanInfo, { debug })\n            : new Channel(this, chanInfo)\n          );\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const info = { reason, description };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR)\n            return;\n\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr,\n                                    null,\n                                    channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          const exit = channel._exit;\n          if (exit.code !== undefined)\n            return;\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n            case 'exit-signal':\n              channel.emit('exit',\n                           exit.code = null,\n                           exit.signal = `SIG${data.signal}`,\n                           exit.dump = data.coreDumped,\n                           exit.desc = data.errorMessage);\n              return;\n          }\n\n          // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n          if (wantReply)\n            p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.incoming.state !== 'open')\n            return;\n          channel.incoming.state = 'eof';\n\n          if (channel.readable)\n            channel.push(null);\n          if (channel.stderr.readable)\n            channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        },\n      },\n    });\n\n    sock.pause();\n\n    // TODO: check keepalive implementation\n    // Keepalive-related\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n        return;\n      }\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock))\n          katimer = setInterval(sendKA, kainterval);\n      }\n    }\n    this._resetKA = resetKA;\n\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called)\n          return;\n        called = true;\n        if (wasConnected && !sawHeader) {\n          const err =\n            makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called)\n          return;\n        called = true;\n\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', (data) => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n              try {\n                if (isWritable(sock))\n                  sock.end();\n              } catch {}\n            }\n          });\n\n          // Drain stderr if we are connection hopping using an exec stream\n          if (sock.stderr && typeof sock.stderr.resume === 'function')\n            sock.stderr.resume();\n\n          sock.resume();\n        }).catch((err) => {\n          this.emit('error', err);\n          try {\n            if (isWritable(sock))\n              sock.end();\n          } catch {}\n        });\n      };\n    })();\n    let wasConnected = false;\n    sock.on('connect', onConnect)\n        .on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', (err) => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close');\n\n      // Notify outstanding channel requests of disconnection ...\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n      for (let i = 0; i < callbacks_.length; ++i)\n        callbacks_[i](err);\n\n      // Simulate error for any channels waiting to be opened\n      this._chanMgr.cleanup(err);\n    });\n\n    // Begin authentication handling ===========================================\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined)\n      authsAllowed.push('password');\n    if (privateKey !== undefined)\n      authsAllowed.push('publickey');\n    if (this._agent !== undefined)\n      authsAllowed.push('agent');\n    if (this.config.tryKeyboard)\n      authsAllowed.push('keyboard-interactive');\n    if (privateKey !== undefined\n        && this.config.localHostname !== undefined\n        && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n\n    if (Array.isArray(authHandler))\n      authHandler = makeSimpleAuthHandler(authHandler);\n    else if (typeof authHandler !== 'function')\n      authHandler = makeSimpleAuthHandler(authsAllowed);\n\n    let hasSentAuth = false;\n    const doNextAuth = (nextAuth) => {\n      if (hasSentAuth)\n        return;\n      hasSentAuth = true;\n\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1)\n          return skipAuth(`Authentication method not allowed: ${type}`);\n\n        const username = this.config.username;\n        switch (type) {\n          case 'password':\n            nextAuth = { type, username, password: this.config.password };\n            break;\n          case 'publickey':\n            nextAuth = { type, username, key: privateKey };\n            break;\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername,\n            };\n            break;\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent),\n            };\n            break;\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: (...args) => this.emit('keyboard-interactive', ...args),\n            };\n            break;\n          case 'none':\n            nextAuth = { type, username };\n            break;\n          default:\n            return skipAuth(\n              `Skipping unsupported authentication method: ${nextAuth}`\n            );\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(\n          `Skipping invalid authentication attempt: ${nextAuth}`\n        );\n      } else {\n        const username = nextAuth.username;\n        if (typeof username !== 'string') {\n          return skipAuth(\n            `Skipping invalid authentication attempt: ${nextAuth}`\n          );\n        }\n        const type = nextAuth.type;\n        switch (type) {\n          case 'password': {\n            const { password } = nextAuth;\n            if (typeof password !== 'string' && !Buffer.isBuffer(password))\n              return skipAuth('Skipping invalid password auth attempt');\n            nextAuth = { type, username, password };\n            break;\n          }\n          case 'publickey': {\n            const key = parseKey(nextAuth.key, nextAuth.passphrase);\n            if (key instanceof Error)\n              return skipAuth('Skipping invalid key auth attempt');\n            if (!key.isPrivateKey())\n              return skipAuth('Skipping non-private key');\n            nextAuth = { type, username, key };\n            break;\n          }\n          case 'hostbased': {\n            const { localHostname, localUsername } = nextAuth;\n            const key = parseKey(nextAuth.key, nextAuth.passphrase);\n            if (key instanceof Error\n                || typeof localHostname !== 'string'\n                || typeof localUsername !== 'string') {\n              return skipAuth('Skipping invalid hostbased auth attempt');\n            }\n            if (!key.isPrivateKey())\n              return skipAuth('Skipping non-private key');\n            nextAuth = { type, username, key, localHostname, localUsername };\n            break;\n          }\n          case 'agent': {\n            let agent = nextAuth.agent;\n            if (typeof agent === 'string' && agent.length) {\n              agent = createAgent(agent);\n            } else if (!isAgent(agent)) {\n              return skipAuth(\n                `Skipping invalid agent: ${nextAuth.agent}`\n              );\n            }\n            nextAuth = { type, username, agentCtx: new AgentContext(agent) };\n            break;\n          }\n          case 'keyboard-interactive': {\n            const { prompt } = nextAuth;\n            if (typeof prompt !== 'function') {\n              return skipAuth(\n                'Skipping invalid keyboard-interactive auth attempt'\n              );\n            }\n            nextAuth = { type, username, prompt };\n            break;\n          }\n          case 'none':\n            nextAuth = { type, username };\n            break;\n          default:\n            return skipAuth(\n              `Skipping unsupported authentication method: ${nextAuth}`\n            );\n        }\n      }\n      curAuth = nextAuth;\n\n      // Begin authentication method's process\n      try {\n        const username = curAuth.username;\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n          case 'publickey':\n            proto.authPK(username, curAuth.key);\n            break;\n          case 'hostbased':\n            proto.authHostbased(username,\n                                curAuth.key,\n                                curAuth.localHostname,\n                                curAuth.localUsername,\n                                (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n              if (signature instanceof Error) {\n                signature.message =\n                  `Error while signing with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n\n              cb(signature);\n            });\n            break;\n          case 'agent':\n            curAuth.agentCtx.init((err) => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n              tryNextAgentKey();\n            });\n            break;\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined)\n        return;\n      doNextAuth(auth);\n    }\n\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key);\n        }\n      }\n    };\n\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setNoDelay(true);\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n\n      if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6)) {\n        doConnect();\n      } else {\n        dnsLookup(host, (forceIPv4 ? 4 : 6), (err, address, family) => {\n          if (err) {\n            const type = (forceIPv4 ? 'IPv4' : 'IPv6');\n            const error = new Error(\n              `Error while looking up ${type} address for '${host}': ${err}`\n            );\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n\n    return this;\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    const extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };\n\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length)\n          todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true\n          || (opts\n              && opts.agentForward === true\n              && this._agent !== undefined)) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null)\n          reqEnv(chan, opts.env);\n        if ((typeof opts.pty === 'object' && opts.pty !== null)\n            || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n        if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n            || opts.x11 === 'number'\n            || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n\n    return this;\n  }\n\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length)\n          todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true\n          || (opts\n              && opts.agentForward === true\n              && this._agent !== undefined)) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (wndopts !== false)\n        todo.push(() => reqPty(chan, wndopts, reqCb));\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null)\n          reqEnv(chan, opts.env);\n        if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n            || opts.x11 === 'number'\n            || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n\n    return this;\n  }\n\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        cb(undefined, stream);\n      });\n    });\n\n    return this;\n  }\n\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = (typeof cb === 'function');\n\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true\n             ? had_err\n             : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        let realPort = bindPort;\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))\n            bindPort = realPort;\n        }\n\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n\n        cb(undefined, realPort);\n      });\n    }\n\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = (typeof cb === 'function');\n\n    if (wantReply) {\n      this._callbacks.push((had_err) => {\n        if (had_err) {\n          cb(had_err !== true\n             ? had_err\n             : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n\n        cb();\n      });\n    }\n\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n\n    if (typeof cb !== 'function')\n      cb = noop;\n\n    openChannel(this, 'direct-tcpip', cfg, cb);\n\n    return this;\n  }\n\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error('Unable to disable future sessions'));\n            return;\n          }\n\n          cb();\n        });\n      }\n\n      this._protocol.openssh_noMoreSessions(wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof cb !== 'function')\n      cb = noop;\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      openChannel(this, 'direct-streamlocal@openssh.com', { socketPath }, cb);\n      return this;\n    }\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number')\n            msg = `Received exit code ${code} while establishing SFTP session`;\n          else if (signal !== undefined)\n            msg = `Received signal ${signal} while establishing SFTP session`;\n          else\n            msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n\n        sftp.on('ready', onReady)\n            .on('error', onError)\n            .on('exit', onExit)\n            .on('close', onExit);\n\n        sftp._init();\n      });\n    });\n\n    return this;\n  }\n}\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n      break;\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(\n        localChan, initWindow, maxPacket, opts\n      );\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean')\n      cfg.single = screen.single;\n    if (typeof screen.screen === 'number')\n      cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string')\n      cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string')\n      cfg.cookie = screen.cookie;\n    else if (Buffer.isBuffer(screen.cookie))\n      cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n  if (cfg.cookie === undefined)\n    cfg.cookie = randomCookie();\n\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply)\n      cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push((had_err) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11)\n          --chan._client._acceptX11;\n      });\n\n      cb();\n    });\n  }\n\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number')\n      rows = opts.rows;\n    if (typeof opts.cols === 'number')\n      cols = opts.cols;\n    if (typeof opts.width === 'number')\n      width = opts.width;\n    if (typeof opts.height === 'number')\n      height = opts.height;\n    if (typeof opts.term === 'string')\n      term = opts.term;\n    if (typeof opts.modes === 'object')\n      modes = opts.modes;\n  }\n\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply)\n      cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push((had_err) => {\n      if (had_err) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n      cb();\n    });\n  }\n\n  chan._client._protocol.pty(chan.outgoing.id,\n                             rows,\n                             cols,\n                             height,\n                             width,\n                             term,\n                             modes,\n                             wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      if (wantReply) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Unable to request agent forwarding'));\n      }\n      return;\n    }\n\n    if (wantReply)\n      cb();\n  });\n\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = (opts.allowHalfOpen !== false);\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open')\n    return;\n\n  const keys = Object.keys(env || {});\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true\n         ? had_err\n         : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n}\n\n// TODO: inline implementation into single call site\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  let localChan = -1;\n  let reason;\n\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n    self._chanMgr.update(localChan, stream);\n\n    self._protocol.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      MAX_WINDOW,\n                                      PACKET_SIZE);\n    return stream;\n  };\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1)\n        reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      else\n        reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    if (localChan !== -1)\n      self._chanMgr.remove(localChan);\n\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      if (self.config.debug) {\n        self.config.debug(\n          'Client: Automatic rejection of incoming channel open: '\n            + 'no channels available'\n        );\n      }\n    }\n\n    return (localChan !== -1);\n  };\n\n  const data = info.data;\n  switch (info.type) {\n    case 'forwarded-tcpip': {\n      const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n      if (val !== undefined && reserveChannel()) {\n        if (data.destPort === 0)\n          data.destPort = val;\n        self.emit('tcp connection', data, accept, reject);\n        return;\n      }\n      break;\n    }\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined\n          && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n      break;\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled\n          && typeof self._agent.getStream === 'function'\n          && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err)\n            return reject();\n\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n        return;\n      }\n      break;\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n      break;\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n      if (self.config.debug) {\n        self.config.debug(\n          'Client: Automatic rejection of unsupported incoming channel open '\n            + `type: ${info.type}`\n        );\n      }\n  }\n\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n    if (self.config.debug) {\n       self.config.debug(\n        'Client: Automatic rejection of unexpected incoming channel open for: '\n          + info.type\n      );\n    }\n  }\n\n  reject();\n}\n\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\n\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList))\n    throw new Error('authList must be an array');\n\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length)\n      return false;\n    return authList[a++];\n  };\n}\n\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock))\n    return;\n\n  if (typeof cb !== 'function')\n    cb = noop;\n\n  if (!Array.isArray(keys_))\n    throw new TypeError('Invalid keys argument type');\n\n  const keys = [];\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error)\n      throw parsed;\n    keys.push(parsed);\n  }\n\n  if (!client.config.strictVendor\n      || (client.config.strictVendor && RE_OPENSSH.test(client._remoteVer))) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Server failed to prove supplied keys'));\n        return;\n      }\n\n      // TODO: move all of this parsing/verifying logic out of the client?\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length)\n          break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n\n        let algo;\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(\n          4 + 29 + 4 + sessionID.length + 4 + keyPublic.length\n        );\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n\n        if (!(value = sigSSHToASN1(value, type)))\n          continue;\n        if (key.verify(verifyData, value, algo) === true)\n          ret.push(key);\n      }\n      sigParser.clear();\n      bufferParser.clear();\n\n      cb(null, ret);\n    });\n\n    client._protocol.openssh_hostKeysProve(keys);\n    return;\n  }\n\n  process.nextTick(\n    cb,\n    new Error(\n      'strictVendor enabled and server is not OpenSSH or compatible version'\n    )\n  );\n}\n\nmodule.exports = Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}